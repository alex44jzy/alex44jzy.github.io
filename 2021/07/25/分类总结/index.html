<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode," />





  <link rel="alternate" href="/atom.xml" title="SciAes" type="application/atom+xml" />






<meta name="description" content="目录 双指针  LC-1 2数求和  先带上index排序   LC-15 三数之和 排序，3指针: i，left=i+1, right=len(nums)-1；i/left/right都需要考虑去重 LC-16 最接近的三数之和 同，排序，3指针 LC-75 颜色分类 荷兰旗，head,mid=0,tail=n-1, mid=0交换mid和head前进, mid=2交换mid和tail，tail">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="分类总结">
<meta property="og:url" content="http://alexjiangzy.com/2021/07/25/分类总结/index.html">
<meta property="og:site_name" content="SciAes">
<meta property="og:description" content="目录 双指针  LC-1 2数求和  先带上index排序   LC-15 三数之和 排序，3指针: i，left=i+1, right=len(nums)-1；i/left/right都需要考虑去重 LC-16 最接近的三数之和 同，排序，3指针 LC-75 颜色分类 荷兰旗，head,mid=0,tail=n-1, mid=0交换mid和head前进, mid=2交换mid和tail，tail">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg">
<meta property="og:updated_time" content="2021-10-20T06:50:01.993Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分类总结">
<meta name="twitter:description" content="目录 双指针  LC-1 2数求和  先带上index排序   LC-15 三数之和 排序，3指针: i，left=i+1, right=len(nums)-1；i/left/right都需要考虑去重 LC-16 最接近的三数之和 同，排序，3指针 LC-75 颜色分类 荷兰旗，head,mid=0,tail=n-1, mid=0交换mid和head前进, mid=2交换mid和tail，tail">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://alexjiangzy.com/2021/07/25/分类总结/"/>




<link rel="stylesheet" href="/js/prism/prism.css">


  <title>分类总结 | SciAes</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-117094882-1', 'auto');
  ga('send', 'pageview');
</script>






</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SciAes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">机器学习的自我重建之路</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-lab">
          <a href="/lab" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Lab
          </a>
        </li>
      
        
        <li class="menu-item menu-item-fav">
          <a href="/Fav" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Fav
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://alexjiangzy.com/2021/07/25/分类总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Jiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SciAes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分类总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-25T00:12:44+08:00">
                2021-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/07/25/分类总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2021/07/25/分类总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1>目录</h1>
<h2 id="双指针">双指针</h2>
<ul>
<li><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0"></label><a href="#p1">LC-1 2数求和</a>
<ul>
<li>先带上index排序</li>
</ul>
</li>
<li><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1"></label><a href="#p15">LC-15 三数之和</a><br>
排序，3指针: i，left=i+1, right=len(nums)-1；i/left/right都需要考虑去重</li>
<li><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2"></label><a href="#p16">LC-16 最接近的三数之和</a><br>
同，排序，3指针</li>
<li><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3"></label><a href="#p75">LC-75 颜色分类</a><br>
荷兰旗，head,mid=0,tail=n-1, mid=0交换mid和head前进, mid=2交换mid和tail，tail-1, 不然mid+1</li>
<li><input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4"></label><a href="#p11">LC-11 盛最多水的容器</a><br>
首尾指针，wide=j-i, height=min(h[i], h[j]), max(wide*height)</li>
<li><input type="checkbox" id="checkbox5" checked="true"><label for="checkbox5"></label><a href="#p763">LC-763 划分字母区间</a><br>
转成字典，key:字母，value:[start, end]的index，合并区间模板</li>
<li><input type="checkbox" id="checkbox6" checked="true"><label for="checkbox6"></label><a href="#p80">LC-80 删除排序数组中的重复项</a><br>
重复k个的问题。核心：if i &lt; k or nums[i] != nums[length - k]，重新组织数组</li>
</ul>
<a id="more"></a>
<h2 id="动态规划">动态规划</h2>
<ul>
<li><input type="checkbox" id="checkbox7" checked="true"><label for="checkbox7"></label><a href="#p300">LC-300 最长上升子序列</a><br>
i和j，初始化全长1，dp[i] = max(dp[i], dp[j]+1) if nums[i] &gt; nums[j]</li>
<li><input type="checkbox" id="checkbox8" checked="true"><label for="checkbox8"></label><a href="#p1143">LC-1143 最长公共子序列</a><br>
二维dp，初始化 n+1 和 m+1, 对角线更新</li>
<li><input type="checkbox" id="checkbox9" checked="true"><label for="checkbox9"></label><a href="#p673">LC-673 最长递增子序列的个数</a><br>
LIS变种，维护一个count计数器，</li>
<li><input type="checkbox" id="checkbox10" checked="true"><label for="checkbox10"></label><a href="#p5">LC-5 最长回文子串</a><br>
二维dp，初始化全长，对角线单个字符，连续，左右缩进为true，更新最长length</li>
<li><input type="checkbox" id="checkbox11" checked="true"><label for="checkbox11"></label><a href="#p647">LC-647 回文子串</a><br>
二维dp，初始化全长，对角线单个字符，连续，左右缩进为true，累加</li>
<li><input type="checkbox" id="checkbox12" checked="true"><label for="checkbox12"></label><a href="#p516">LC-516 最长回文子序列</a><br>
二维dp，后向遍历</li>
<li><input type="checkbox" id="checkbox13" checked="true"><label for="checkbox13"></label><a href="#p221">LC-221 最大正方形</a><br>
二维dp，初始化+1全长，和上左对角比较</li>
<li><input type="checkbox" id="checkbox14" checked="true"><label for="checkbox14"></label><a href="#p322">LC-322 零钱兑换</a><br>
dp，初始化全长+1正无穷，序列长度是金额数，取或不取</li>
<li><input type="checkbox" id="checkbox15" checked="true"><label for="checkbox15"></label><a href="#p718">LC-718 最长重复子数组</a><br>
二维dp，初始化+1全长，dp[i][j] = dp[i-1][j-1] + 1</li>
<li><input type="checkbox" id="checkbox16" checked="true"><label for="checkbox16"></label><a href="#p198">LC-198 打劫家舍</a><br>
dp，偷和不偷，初始化全长为对应数字</li>
<li><input type="checkbox" id="checkbox17" checked="true"><label for="checkbox17"></label><a href="#p213">LC-213 打劫家舍2</a><br>
dp，环形问题，化解成2个一般的问题</li>
<li><input type="checkbox" id="checkbox18" checked="true"><label for="checkbox18"></label><a href="#p62">LC-62 不同路经</a><br>
二维dp，初始化全长，贴边为1，上和左求和</li>
<li><input type="checkbox" id="checkbox19" checked="true"><label for="checkbox19"></label><a href="#p63">LC-63 不同路径2</a><br>
二维dp，初始化全长，外围一圈有障碍及余下就为0</li>
<li><input type="checkbox" id="checkbox20" checked="true"><label for="checkbox20"></label><a href="#p64">LC-64 最小路经和</a><br>
二维dp，初始化全长，贴边初始化</li>
<li><input type="checkbox" id="checkbox21" checked="true"><label for="checkbox21"></label><a href="#p152">LC-152 乘积最大子数组</a><br>
乘积需要维护最大和最小值</li>
<li><input type="checkbox" id="checkbox22" checked="true"><label for="checkbox22"></label><a href="#p523">LC-523 连续的子数组和</a><br>
前缀和</li>
<li><input type="checkbox" id="checkbox23" checked="true"><label for="checkbox23"></label><a href="#p139">LC-139 单词拆分</a></li>
<li><input type="checkbox" id="checkbox24"><label for="checkbox24">LC-91 解码方法</label></li>
<li><input type="checkbox" id="checkbox25" checked="true"><label for="checkbox25"></label><a href="#p264">LC-264 丑数2</a></li>
<li><input type="checkbox" id="checkbox26"><label for="checkbox26">LC-96 不同的二叉搜索树</label></li>
<li><input type="checkbox" id="checkbox27" checked="true"><label for="checkbox27"></label><a href="#p279">LC-279 完全平方数</a><br>
dp，初始化为全长该位置数字，dp为减去平方数加1</li>
<li><input type="checkbox" id="checkbox28" checked="true"><label for="checkbox28"></label><a href="#p309">LC-309 股票买卖</a></li>
<li><input type="checkbox" id="checkbox29" checked="true"><label for="checkbox29"></label><a href="#p188">LC-188 买卖股票最佳时机</a></li>
<li><input type="checkbox" id="checkbox30" checked="true"><label for="checkbox30"></label><a href="#p343">LC-343 整数拆分</a></li>
<li><input type="checkbox" id="checkbox31" checked="true"><label for="checkbox31"></label><a href="#p416">LC-416 分割等和子集</a><br>
除以2，转化为01背包问题</li>
<li><input type="checkbox" id="checkbox32" checked="true"><label for="checkbox32"></label><a href="#p42">LC-42 接雨水</a><br>
双指针</li>
<li><input type="checkbox" id="checkbox33" checked="true"><label for="checkbox33"></label><a href="#p32">LC-32 最长有效括号</a><br>
使用堆，堆内放-1，左括号压入，右括号直接弹出</li>
<li><input type="checkbox" id="checkbox34" checked="true"><label for="checkbox34"></label><a href="#p72">LC-72 编辑距离</a></li>
<li><input type="checkbox" id="checkbox35"><label for="checkbox35">LC-10 正则表达式匹配</label></li>
<li><input type="checkbox" id="checkbox36"><label for="checkbox36">LC-44 通配符匹配</label></li>
</ul>
<h2 id="树">树</h2>
<ul>
<li><input type="checkbox" id="checkbox37" checked="true"><label for="checkbox37"></label><a href="#p103">LC-103 二叉树锯齿层次遍历</a></li>
<li><input type="checkbox" id="checkbox38" checked="true"><label for="checkbox38"></label><a href="#p102">LC-102 二叉树的层序遍历</a></li>
<li><input type="checkbox" id="checkbox39" checked="true"><label for="checkbox39"></label><a href="#p107">LC-107 二叉树层序遍历2</a></li>
<li><input type="checkbox" id="checkbox40" checked="true"><label for="checkbox40"></label><a href="#p236">LC-236 二叉树最近公共祖先</a></li>
<li><input type="checkbox" id="checkbox41" checked="true"><label for="checkbox41"></label><a href="#p98">LC-98 验证二叉搜索树</a></li>
<li><input type="checkbox" id="checkbox42" checked="true"><label for="checkbox42"></label><a href="#p199">LC-199 二叉树的右视图</a></li>
<li><input type="checkbox" id="checkbox43" checked="true"><label for="checkbox43"></label><a href="#p101">LC-101 对称二叉树</a></li>
<li><input type="checkbox" id="checkbox44" checked="true"><label for="checkbox44"></label><a href="#p105">LC-105 从前序与中序遍历序列构造二叉树</a></li>
<li><input type="checkbox" id="checkbox45" checked="true"><label for="checkbox45"></label><a href="#p112">LC-112 路径总和</a></li>
<li><input type="checkbox" id="checkbox46" checked="true"><label for="checkbox46"></label><a href="#p113">LC-113 路径总和2</a></li>
<li><input type="checkbox" id="checkbox47" checked="true"><label for="checkbox47"></label><a href="#p124">LC-124 二叉树中的最大路径和</a></li>
<li><input type="checkbox" id="checkbox48" checked="true"><label for="checkbox48"></label><a href="#p129">LC-129 根到叶子节点数字之和</a></li>
<li><input type="checkbox" id="checkbox49" checked="true"><label for="checkbox49"></label><a href="#p958">LC-958 二叉树完全性检验</a></li>
<li><input type="checkbox" id="checkbox50" checked="true"><label for="checkbox50"></label><a href="#p104">LC-104 二叉树最大深度</a></li>
<li><input type="checkbox" id="checkbox51" checked="true"><label for="checkbox51"></label><a href="#p226">LC-226 反转二叉树</a></li>
<li><input type="checkbox" id="checkbox52" checked="true"><label for="checkbox52"></label><a href="#p114">LC-114 二叉树展开成链表</a></li>
<li><input type="checkbox" id="checkbox53" checked="true"><label for="checkbox53"></label><a href="#p230">LC-230 二叉搜索树中第k小的树</a></li>
<li><input type="checkbox" id="checkbox54" checked="true"><label for="checkbox54"></label><a href="#p662">LC-662 二叉树最大宽度</a></li>
<li><input type="checkbox" id="checkbox55"><label for="checkbox55">LC-1302 层数最深叶子节点的和</label></li>
</ul>
<h2 id="链表">链表</h2>
<ul>
<li><input type="checkbox" id="checkbox56" checked="true"><label for="checkbox56"></label><a href="#p206">LC-206 反转链表</a></li>
<li><input type="checkbox" id="checkbox57" checked="true"><label for="checkbox57"></label><a href="#p25">LC-25 K个一组反转链表</a></li>
<li><input type="checkbox" id="checkbox58" checked="true"><label for="checkbox58"></label><a href="#p92">LC-92 反转链表2</a></li>
<li><input type="checkbox" id="checkbox59" checked="true"><label for="checkbox59"></label><a href="#p21">LC-21 合并2个有序链表</a></li>
<li><input type="checkbox" id="checkbox60" checked="true"><label for="checkbox60"></label><a href="#p23">LC-23 合并k个排序链表</a></li>
<li><input type="checkbox" id="checkbox61" checked="true"><label for="checkbox61"></label><a href="#p141">LC-141 环形链表</a></li>
<li><input type="checkbox" id="checkbox62" checked="true"><label for="checkbox62"></label><a href="#p142">LC-142 环形链表2</a></li>
<li><input type="checkbox" id="checkbox63" checked="true"><label for="checkbox63"></label><a href="#p160">LC-160 相交链表</a></li>
<li><input type="checkbox" id="checkbox64" checked="true"><label for="checkbox64"></label><a href="#p19">LC-19 删除链表倒数第N个元素</a></li>
<li><input type="checkbox" id="checkbox65" checked="true"><label for="checkbox65"></label><a href="#p143">LC-143 重排链表</a><br>
找中点；反转链表；合并有序链表</li>
<li><input type="checkbox" id="checkbox66" checked="true"><label for="checkbox66"></label><a href="#p234">LC-234 回文链表</a></li>
<li><input type="checkbox" id="checkbox67" checked="true"><label for="checkbox67"></label><a href="#p148">LC-148 排序链表</a></li>
<li><input type="checkbox" id="checkbox68" checked="true"><label for="checkbox68"></label><a href="#p82">LC-82 删除排序链表中的重复元素</a></li>
<li><input type="checkbox" id="checkbox69" checked="true"><label for="checkbox69"></label><a href="#p83">LC-83 删除排序链表中的重复元素2</a></li>
<li><input type="checkbox" id="checkbox70" checked="true"><label for="checkbox70"></label><a href="#p24">LC-24 两两交换链表中的节点</a></li>
<li><input type="checkbox" id="checkbox71" checked="true"><label for="checkbox71"></label><a href="#p328">LC-328 奇偶链表</a></li>
<li><input type="checkbox" id="checkbox72" checked="true"><label for="checkbox72"></label><a href="#p61">LC-61 旋转链表</a><br>
设定偶链表头，奇偶链表参考: odd.next = even.next; odd = odd.next</li>
<li><input type="checkbox" id="checkbox73"><label for="checkbox73">LC-138 复制带</label></li>
<li><input type="checkbox" id="checkbox74" checked="true"><label for="checkbox74"></label><a href="#p86">LC-86 分隔链表</a></li>
</ul>
<h2 id="数学">数学</h2>
<ul>
<li><input type="checkbox" id="checkbox75" checked="true"><label for="checkbox75"></label><a href="#p2">LC-2 两数相加</a></li>
<li><input type="checkbox" id="checkbox76" checked="true"><label for="checkbox76"></label><a href="#p8">LC-8 字符串转整数</a></li>
<li><input type="checkbox" id="checkbox77" checked="true"><label for="checkbox77"></label><a href="#p50">LC-50 Pow(x,n)</a><br>
递归，2个判断，正负幂，剩余n是否是2的倍数</li>
<li><input type="checkbox" id="checkbox78"><label for="checkbox78">LC-400 第N个数字</label></li>
<li><input type="checkbox" id="checkbox79" checked="true"><label for="checkbox79"></label><a href="#p43">LC-43 字符串相乘</a></li>
<li><input type="checkbox" id="checkbox80" checked="true"><label for="checkbox80"></label><a href="#p470">LC-470 rand7() 实现 rand10()</a></li>
<li><input type="checkbox" id="checkbox81" checked="true"><label for="checkbox81"></label><a href="#p264">LC-264 丑数2</a></li>
<li><input type="checkbox" id="checkbox82" checked="true"><label for="checkbox82"></label><a href="#p279">LC-279 完全平方数</a></li>
<li><input type="checkbox" id="checkbox83" checked="true"><label for="checkbox83"></label><a href="#p12">LC-12 整数转罗马数字</a></li>
<li><input type="checkbox" id="checkbox84"><label for="checkbox84">LC-1201 丑数3</label></li>
<li><input type="checkbox" id="checkbox85"><label for="checkbox85">LC-109 有序链表转换二叉搜索树</label></li>
<li><input type="checkbox" id="checkbox86"><label for="checkbox86">LC-369 单链表加一</label></li>
<li><input type="checkbox" id="checkbox87"><label for="checkbox87">LC-41 缺失的第一个正数</label></li>
</ul>
<h2 id="滑动窗口">滑动窗口</h2>
<p>（子串一般都是是滑动窗口法，子串求和使用前缀和）</p>
<ul>
<li><input type="checkbox" id="checkbox88" checked="true"><label for="checkbox88"></label><a href="#p523">LC-523 连续的子数组和</a></li>
<li><input type="checkbox" id="checkbox89" checked="true"><label for="checkbox89"></label><a href="#p3">LC-3 无重复字符的最长子串</a></li>
<li><input type="checkbox" id="checkbox90" checked="true"><label for="checkbox90"></label><a href="#p395">LC-395 至少有k个重复字符子串</a></li>
<li><input type="checkbox" id="checkbox91" checked="true"><label for="checkbox91"></label><a href="#p76">LC-76 最小覆盖子串</a></li>
<li><input type="checkbox" id="checkbox92" checked="true"><label for="checkbox92"></label><a href="#p239">LC-239 滑动窗口最大值</a>(栈)</li>
<li><input type="checkbox" id="checkbox93"><label for="checkbox93">LC-209 长度最小的子数组</label></li>
<li><input type="checkbox" id="checkbox94"><label for="checkbox94"></label><a href="#p340">LC-340 至多包含k个不同字符的最长子串</a></li>
</ul>
<h2 id="二分查找">二分查找</h2>
<ul>
<li><input type="checkbox" id="checkbox95" checked="true"><label for="checkbox95"></label><a href="#p33">LC-33 搜索旋转排序数组</a></li>
<li><input type="checkbox" id="checkbox96" checked="true"><label for="checkbox96"></label><a href="#p162">LC-162 寻找峰值</a></li>
<li><input type="checkbox" id="checkbox97" checked="true"><label for="checkbox97"></label><a href="#p240">LC-240 搜索二维矩阵2</a></li>
<li><input type="checkbox" id="checkbox98" checked="true"><label for="checkbox98"></label><a href="#p718">LC-718 最长重复子数组</a></li>
<li><input type="checkbox" id="checkbox99" checked="true"><label for="checkbox99"></label><a href="#p31">LC-31 下一个排列</a></li>
<li><input type="checkbox" id="checkbox100" checked="true"><label for="checkbox100"></label><a href="#p230">LC-230 二叉搜索树中第k小的元素</a></li>
<li><input type="checkbox" id="checkbox101"><label for="checkbox101">LC-34 排序数组中查找第一个和最后一个位置</label></li>
<li><input type="checkbox" id="checkbox102"><label for="checkbox102">LC-287 寻找重复数</label></li>
<li><input type="checkbox" id="checkbox103"><label for="checkbox103">补充题7 木头切割问题</label></li>
<li><input type="checkbox" id="checkbox104"><label for="checkbox104">LC-528 按权重随机选择</label></li>
<li><input type="checkbox" id="checkbox105"><label for="checkbox105">LC-153 寻找旋转排序数组中的最小值</label></li>
</ul>
<h2 id="回溯">回溯</h2>
<ul>
<li><input type="checkbox" id="checkbox106" checked="true"><label for="checkbox106"></label><a href="#p46">LC-46 全排列</a></li>
<li><input type="checkbox" id="checkbox107" checked="true"><label for="checkbox107"></label><a href="#p78">LC-78 子集</a></li>
<li><input type="checkbox" id="checkbox108" checked="true"><label for="checkbox108"></label><a href="#p77">LC-77 组合</a></li>
<li><input type="checkbox" id="checkbox109" checked="true"><label for="checkbox109"></label><a href="#p39">LC-39 组合总和</a></li>
<li><input type="checkbox" id="checkbox110" checked="true"><label for="checkbox110"></label><a href="#p22">LC-22 括号生成</a></li>
<li><input type="checkbox" id="checkbox111" checked="true"><label for="checkbox111"></label><a href="#p79">LC-79 单词搜索</a></li>
<li><input type="checkbox" id="checkbox112" checked="true"><label for="checkbox112"></label><a href="#p47">LC-47 全排列2</a></li>
<li><input type="checkbox" id="checkbox113" checked="true"><label for="checkbox113"></label><a href="#p40">LC-40 组合总和2</a></li>
<li><input type="checkbox" id="checkbox114"><label for="checkbox114">LC-17 电话号码的字母组合</label></li>
<li><input type="checkbox" id="checkbox115"><label for="checkbox115">LC-306 累加数</label></li>
</ul>
<h2 id="DFS-BFS">DFS/BFS</h2>
<ul>
<li><input type="checkbox" id="checkbox116" checked="true"><label for="checkbox116"></label><a href="#p200">LC-200 岛屿数量</a></li>
<li><input type="checkbox" id="checkbox117" checked="true"><label for="checkbox117"></label><a href="#p695">LC-695 岛屿最大面积</a></li>
<li><input type="checkbox" id="checkbox118" checked="true"><label for="checkbox118"></label><a href="#p394">LC-394 字符串解码</a></li>
<li><input type="checkbox" id="checkbox119" checked="true"><label for="checkbox119"></label><a href="#p207">LC-207 课程表</a></li>
<li><input type="checkbox" id="checkbox120" checked="true"><label for="checkbox120"></label><a href="#p106">LC-106 从中序遍历和后序遍历构造二叉树</a></li>
<li><input type="checkbox" id="checkbox121"><label for="checkbox121">LC-547 省份数量</label></li>
<li><input type="checkbox" id="checkbox122"><label for="checkbox122">LC-494 目标和</label></li>
<li><input type="checkbox" id="checkbox123"><label for="checkbox123">LC-17 电话号码字母组合</label></li>
<li><input type="checkbox" id="checkbox124"><label for="checkbox124">LC-337 打劫家舍3</label></li>
</ul>
<h2 id="字符串">字符串</h2>
<ul>
<li><input type="checkbox" id="checkbox125" checked="true"><label for="checkbox125"></label><a href="#p151">LC-151 反转字符串里的单词</a></li>
<li><input type="checkbox" id="checkbox126" checked="true"><label for="checkbox126"></label><a href="#p165">LC-165 比较版本号</a></li>
<li><input type="checkbox" id="checkbox127" checked="true"><label for="checkbox127"></label><a href="#p93">LC-93 复原IP地址</a></li>
<li><input type="checkbox" id="checkbox128" checked="true"><label for="checkbox128"></label><a href="#p227">LC-227 基本计算器2</a><br>
使用单栈，注意数字</li>
<li><input type="checkbox" id="checkbox129"><label for="checkbox129">LC-443 压缩字符串</label></li>
<li><input type="checkbox" id="checkbox130"><label for="checkbox130">LC-556 下一个更大的元素3</label></li>
<li><input type="checkbox" id="checkbox131"><label for="checkbox131">LC-71 简化路径</label></li>
<li><input type="checkbox" id="checkbox132"><label for="checkbox132">LC-17 电话号码字母组合</label></li>
<li><input type="checkbox" id="checkbox133"><label for="checkbox133">LC-6 Z字形变换</label></li>
<li><input type="checkbox" id="checkbox134"><label for="checkbox134">LC-678 有效括号字符串</label></li>
<li><input type="checkbox" id="checkbox135"><label for="checkbox135">LC-97 交错字符串</label></li>
<li><input type="checkbox" id="checkbox136"><label for="checkbox136">LC-767 重构字符串</label></li>
<li><input type="checkbox" id="checkbox137"><label for="checkbox137">LC-179 最大数</label></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li><input type="checkbox" id="checkbox138" checked="true"><label for="checkbox138"></label><a href="#p215">LC-215 第K大的元素</a></li>
<li><input type="checkbox" id="checkbox139" checked="true"><label for="checkbox139"></label><a href="#p146">LC-146 LRU缓存机制</a></li>
<li><input type="checkbox" id="checkbox140" checked="true"><label for="checkbox140"></label><a href="#p54">LC-54 旋转矩阵</a></li>
</ul>
<h1>双指针</h1>
<h3 id="a-name-p1-a-LC-1-2数求和"><a name="p1"></a> <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LC-1 2数求和</a></h3>
<p><code>双指针</code></p>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>
你可以按任意顺序返回答案。</p>
<p>Given nums = [2, 7, 11, 15], target = 9,<br>
Because nums[0] + nums[1] = 2 + 7 = 9,<br>
return [0, 1].</p>
<p>用一个dict来保存数据，key为数字，value为索引，代码如下：</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        mem = dict()
        
        for index, item in enumerate(nums):
            if item in mem:
                return [mem[item], index]
            else:
                mem[target - item] = index
</code></pre>
<p>双指针套路：</p>
<pre><code class="language-python">class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        sn = sorted((num, i) for i, num in enumerate(nums))
        i, j = 0, len(nums) - 1
        print(sn)
        while i &lt; j:
            n, k = sn[i]
            m, l = sn[j]
            if n + m &lt; target:
                i += 1
            elif n + m &gt; target:
                j -= 1
            else:
                return [k, l]
</code></pre>
<p>这里将原数组，转化为(value, index)一个tuple类型。对这个tuple类型进行了排序，这样既保留了原有的index和value，又排了顺序。然后就是常规的步骤了，两个指针各指向一头，如果大于target就移动右指针，反之移动左指针。最近发现很多问题都有涉及对这个tuple的运用，真的是一个很高阶的技能。</p>
<h3 id="a-name-p15-a-LC-15-3数求和"><a name="p15"></a> <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LC-15 3数求和</a></h3>
<p><code>双指针</code><br>
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>
注意：答案中不可以包含<strong>重复</strong>的三元组。</p>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>
输出：[[-1,-1,2],[-1,0,1]]</p>
<pre><code class="language-python">class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        ans = []
        if len(nums) &lt;=2:
            return ans
        # sort array
        nums.sort()

        for i in range(len(nums)):
            if nums[i] &gt; 0:
                return ans
            left = i + 1
            right = len(nums) - 1
            if (i &gt; 0 and nums[i] == nums[i-1]): # i 要考虑和前一个连续相同
                continue
            while left &lt; right:
                if nums[i] + nums[left] + nums[right] &lt; 0:
                    left += 1
                elif nums[i] + nums[left] + nums[right] &gt; 0:
                    right -= 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    while left &lt; right and nums[left] == nums[left+1]:
                        left += 1 # left考虑和后一个连续相同
                    while right &gt; left and nums[right] == nums[right-1]:
                        right -= 1 # right 考虑和前一个连续相同
                    left += 1
                    right -= 1
        return ans
</code></pre>
<p>依然是双指针经典模板，if elif else 三段式；要避开连续所以要考虑和后一位的关系，多利用while来做连续判断。</p>
<h3 id="a-name-p16-a-LC-16-最接近的三数之和"><a name="p16"></a> <a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">LC-16 最接近的三数之和</a></h3>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：<br>
输入：nums = [-1,2,1,-4], target = 1<br>
输出：2<br>
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p>
<p>排序+双指针</p>
<pre><code class="language-python">class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:
        if len(nums) &lt;=3:
            return sum(nums)
        n = len(nums)
        nums.sort()
        res = sum(nums[:3])
        for i in range(n-2):
            left = i + 1
            right = n - 1            
            while left &lt; right:
                ans = nums[i] + nums[left] + nums[right]
                if ans &gt; target:
                    right -= 1
                elif ans &lt; target:
                    left += 1
                else:
                    res = ans
                    break
                
                if abs(ans-target) &lt; abs(res-target):
                    res = ans
        return res
</code></pre>
<h3 id="a-name-p75-a-LC-75-颜色分类"><a name="p75"></a> <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">LC-75 颜色分类</a></h3>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>
示例 1：<br>
输入：nums = [2,0,2,1,1,0]<br>
输出：[0,0,1,1,2,2]</p>
<p>遍历一遍</p>
<pre><code class="language-python">class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        # 荷兰国旗问题
        n = len(nums)
        start = 0

        for i in range(0, n):
            if nums[i] == 0:
                nums[start], nums[i] = nums[i], nums[start]
                start += 1
        
        for i in range(start, n):
            if nums[i] == 1:
                nums[start], nums[i] = nums[i], nums[start]
                start += 1
</code></pre>
<p>荷兰国旗经典解法：</p>
<pre><code class="language-python">class Solution:
    def sortColors(self, nums: List[int]):
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        # 荷兰国旗问题
        head = 0
        tail = len(nums) - 1
        mid = 0
        while mid &lt;= tail:
            if nums[mid] == 0:
                nums[head], nums[mid] = nums[mid], nums[head]
                head += 1
                mid += 1
            elif nums[mid] == 2:
                nums[mid], nums[tail] = nums[tail], nums[mid]
                tail -= 1
            else:
                mid += 1
</code></pre>
<h3 id="a-name-p11-a-LC-11-盛最多水的容器"><a name="p11"></a> <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">LC-11 盛最多水的容器</a></h3>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>
说明：你不能倾斜容器。</p>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>
输出：49<br>
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>双指针，首尾指针代表面积</p>
<pre><code class="language-python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        length = len(height)
        max_area = 0
        i = 0
        j = length - 1
        while i &lt; j:
            wide = j - i
            high = min(height[i], height[j])
            area = high * wide
            if area &gt; max_area:
                max_area = area
            if height[i] &lt; height[j]:
                i += 1
            else: j -= 1
        return max_area
</code></pre>
<h3 id="a-name-p763-a-LC-763-划分字母区间"><a name="p763"></a> <a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">LC-763 划分字母区间</a></h3>
<p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。<br>
示例：<br>
输入：S = “ababcbacadefegdehijhklij”<br>
输出：[9,7,8]<br>
解释：<br>
划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>
每个字母最多出现在一个片段中。<br>
像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p>
<p>遍历一遍数组，建立字典，key为每个字母，value为首尾index，后将问题转化为合并区间问题。</p>
<p>合并区间模板：</p>
<pre><code class="language-python"># 动态维护
merged = []
intervals.sort()
for interval in intervals:
    if not merged or interval[0] &gt; merged[-1][1]:
        merged.append(interval)
    else:
        # 动态修改最后一个 end index
        merged[-1][1] = max(merged[-1][1], interval[1])
</code></pre>
<pre><code class="language-python">class Solution:
    def partitionLabels(self, s: str) -&gt; List[int]:
        dic = {}
        for i, v in enumerate(s):
            if v in dic.keys():
                st = min(dic[v][0], i)
                ed = max(dic[v][1], i)
                dic[v] = [st, ed]
            else:
                dic[v] = [i, i]
        lt = list(dic.values())
        # 排序是关键
        lt.sort()
        # 合并区间模板
        merged = []
        for interval in lt:
            if not merged or interval[0] &gt; merged[-1][1]:
                merged.append(interval)
            else:
                # 修改最后一个的第二位
                merged[-1][1] = max(merged[-1][1], interval[1])
        return [i[1] - i[0] + 1 for i in merged]
</code></pre>
<h3 id="a-name-p80-a-LC-80-删除有序数组中的重复项-II"><a name="p80"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">LC-80 删除有序数组中的重复项 II</a></h3>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。<br>
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1：<br>
输入：nums = [1,1,1,2,2,3]<br>
输出：5, nums = [1,1,2,2,3]<br>
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</p>
<p>问题核心是只能采用原地模式，即不可以创造新的空间来保存数据。<br>
对于有序数组，重复k个的问题。核心：<strong>if i &lt; k or nums[i] != nums[length - k]</strong></p>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        length = 0
        for i in range(len(nums)):
            # 核心逻辑，排序数组和前n-k个元素比较，不重复保留，指针+1
            if i &lt; 2 or nums[i] != nums[length - 2]:
                nums[length] = nums[i]
                length += 1
        return length
</code></pre>
<h1>动态规划</h1>
<h3 id="a-name-p300-a-LC-300-最长上升子序列"><a name="p300"></a> <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LC-300 最长上升子序列</a></h3>
<p><code>动态规划</code>, <code>递归</code></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>
输入：nums = [10,9,2,5,3,7,101,18]<br>
输出：4<br>
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4</p>
<p><strong>转移方程：dp[i] = max{dp[i], dp[j]+1} if nums[i] &gt; nums[j]</strong></p>
<p>dp[i] 表示这一位上的最长子序列，对于[0, i-1]范围内所有的dp[j]，都需要得到最大</p>
<pre><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        # 不连续
        if len(nums) == 1:
            return 1
        dp = [1] * len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] &gt; nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
</code></pre>
<h3 id="a-name-p1143-a-LC-1143-最长公共子序列"><a name="p1143"></a> <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">LC-1143 最长公共子序列</a></h3>
<p><code>动态规划</code>, <code>递归</code></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。<br>
输入：text1 = “abcde”, text2 = “ace”<br>
输出：3<br>
解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
<p><strong>看到2个字符串，要想到2维的dp问题</strong><br>
<strong>转移方程：dp[i][j] = dp[i-1][j-1] + 1, 当 text1[i-1] = text2[j-1]</strong><br>
<strong>dp[i][j] = max(dp[i-1][j], dp[i][j-1]), 当 text1[i-1] != text2[j-1]</strong></p>
<p>状态初始化要考虑一个字符串是空串的可能性，<br>
当 i = 0 时，dp[0][j] 表示的是 text1 中取空字符串 跟 text2的最长公共子序列，结果肯定为 0.<br>
当 j = 0 时，dp[i][0] 表示的是 text2 中取空字符串 跟 text1的最长公共子序列，结果肯定为 0.<br>
综上，当 i = 0 或者 j = 0 时，dp[i][j] 初始化为 0.</p>
<pre><code class="language-python">class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:
        dp = [[0] * (len(text2) + 1) for i in range(len(text1) + 1)]
        for i in range(1, len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        return dp[-1][-1]
</code></pre>
<h3 id="a-name-p673-a-LC-673-最长递增子序列的个数"><a name="p673"></a> <a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">LC-673 最长递增子序列的个数</a></h3>
<p><code>动态规划</code>, <code>递归</code></p>
<p>给定一个未排序的整数数组，找到最长递增子序列的个数。<br>
输入: [1,3,5,4,7]<br>
输出: 2<br>
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</p>
<p>LIS 问题，除了要知道最长递增子序列的长度以外，题目要知道有这个长度的子序列的数量。</p>
<p><strong>dp[i]：到nums[i]为止的最长递增子序列长度</strong><br>
<strong>count[i]：到nums[i]为止的最长递增子序列个数</strong></p>
<p><strong>if 在nums[i] &gt; nums[j] 分情况</strong><br>
<strong>if dp[j] + 1 &gt; dp[i]，说明最长递增子序列的长度增加了，dp[i] = dp[j] + 1，长度增加，数量不变 count[i] = count[j]</strong><br>
<strong>if dp[j] + 1 == dp[i]，说明最长递增子序列的长度并没有增加，但是出现了长度一样的情况，数量增加 count[i] += count[j]</strong></p>
<p>不断更新最大长度，最后返回所有dp[i] == maxlen 计数器的和</p>
<pre><code class="language-python">class Solution:
    def findNumberOfLIS(self, nums: List[int]):
        n = len(nums)
        if n == 1: 
            return 1
        dp = [1] * n
        count = [1] * n
        max_len = 0
        for i in range(1, n):
            for j in range(i):
                if nums[i] &gt; nums[j]:
                    # 正常情况下，我们直接用 dp[i] = max(dp[1], dp[j]+1)就好
                    # 但是这里我们需要计数，所以拆成下面 if-else 的形式
                    if dp[j] + 1 &gt; dp[i]: # 如果发现：当前长度 &gt; 历史最佳长度
                        dp[i] = dp[j] + 1 # 更新dp[i]， 这一步相当于 dp[i] = max(dp[1], dp[j]+1)
                        count[i] = count[j] # 更新计数器，结果+1，但是计数是不变的
                    elif dp[j] + 1 == dp[i]: # 如果发现：当前长度=历史最佳长度
                        count[i] += count[j] # 更新计数器
            max_len = max(max_len, dp[i]) #找到当前i的位置下，最长的子序列长度
        # 在计数器里面查找最长子序列的总次数
        res = 0
        for i in range(n):
            if dp[i] == max_len:
                res += count[i]
        return res
</code></pre>
<h3 id="a-name-p5-a-LC-5-最长回文子串"><a name="p5"></a> <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LC-5 最长回文子串</a></h3>
<p><code>动态规划</code>, <code>递归</code><br>
给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>输入：s = “babad”<br>
输出：“bab”<br>
解释：“aba” 同样是符合题意的答案。</p>
<p><strong>转移方程：if dp[i-1][j+1] == True and s[i] == s[j], then dp[i][j] = True</strong><br>
要求最长，则需要在循环的时候不断更新最长的长度，以及所对应的起始位置得到子串<br>
注意：初始化矩阵为False的时候，需要把一些简单解先求出来。</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        maxlen = 0
        start = 0
        end = 0

        if len(s) &lt;= 1:
            return s
        
        dp = [[False] * len(s) for i in range(len(s))]

        for i in range(0, len(s)):
            for j in range(0, i + 1):
                if i == j:
                    dp[i][j] = True
                elif i - j == 1 and s[i] == s[j]:
                    dp[i][j] = True
                elif dp[i-1][j+1] and s[i] == s[j]:
                    dp[i][j] = True
                else:
                    continue
                if i-j + 1 &gt; maxlen:
                    maxlen = i - j + 1
                    start = j
                    end = i
        return s[start:end+1]
</code></pre>
<h3 id="a-name-p647-a-LC-647-回文子串"><a name="p647"></a> <a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">LC-647 回文子串</a></h3>
<p><code>动态规划</code>, <code>递归</code><br>
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>
输入：“abc”<br>
输出：3<br>
解释：三个回文子串: “a”, “b”, “c”</p>
<p>输入：“aaa”<br>
输出：6<br>
解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
<p>和LC5一样，区别在于，需要记录结果，且结果可以重复</p>
<pre><code class="language-python">class Solution:
    def countSubstrings(self, s: str) -&gt; int:
        if len(s) &lt;= 1:
            return 1
        dp = [[False] * len(s) for i in range(len(s))]
        res = 0
        for i in range(len(s)):
            for j in range(0, i+1):
                print(i,j)
                if i - j == 0:
                    dp[i][j] = True
                    res += 1
                    continue
                if i - j == 1 and s[i] == s[j]:
                    dp[i][j] = True
                    res += 1
                    continue
                if dp[i-1][j+1] and s[i] == s[j]:
                    dp[i][j] = True
                    res += 1
                    continue
        return res
</code></pre>
<h3 id="a-name-p516-a-LC-516-最长回文子序列"><a name="p516"></a> <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence//" target="_blank" rel="noopener">LC-516 最长回文子序列</a></h3>
<p><code>动态规划</code>, <code>递归</code><br>
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<br>
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p>输入：s = “bbbab”<br>
输出：4<br>
解释：一个可能的最长回文子序列为 “bbbb” 。</p>
<p><strong>转移方程：if s[i] == s[j] then dp[i][j] = dp[i+1][j-1] + 2</strong><br>
<strong>if s[i] != s[j] then dp[i][j] = max(dp[i+1][j], dp[i][j-1])</strong></p>
<pre><code class="language-python">class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
       if len(s) &lt;= 1:
            return 1
        
        dp = [[0] * len(s) for i in range(len(s))]

        for i in range(len(s)):
            dp[i][i] = 1
        # i 是首，j 是尾，循环时i变小，j变大，
        for i in range(len(s) - 1, -1, -1):
            for j in range(i+1, len(s), 1):
                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return dp[0][-1]    
</code></pre>
<h3 id="a-name-p221-a-LC-221-最大正方形"><a name="p221"></a> <a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">LC-221 最大正方形</a></h3>
<p><code>动态规划</code>, <code>递归</code><br>
在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。<br>
输入：matrix = [<br>
[“1”,“0”,“1”,“0”,“0”],<br>
[“1”,“0”,“1”,“1”,“1”],<br>
[“1”,“1”,“1”,“1”,“1”],<br>
[“1”,“0”,“0”,“1”,“0”]<br>
]<br>
输出：4</p>
<p>dp数组中保存每个位置对应的最大正方形的边长<br>
<strong>转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</strong></p>
<pre><code class="language-python">class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][0] = 0
        for j in range(n + 1):
            dp[0][j] = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if matrix[i-1][j-1] == '1':
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                else:
                    dp[i][j] = 0
        return max([max(i) for i in dp]) ** 2
</code></pre>
<h3 id="a-name-p322-a-LC-322-零钱兑换"><a name="p322"></a> <a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LC-322 零钱兑换</a></h3>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>
输出：3<br>
解释：11 = 5 + 5 + 1</p>
<p>dp存储各个金额<br>
<strong>转移方程：dp[i] = min(dp[i], dp[i - coin] + 1)</strong></p>
<pre><code class="language-python">class Solution:
    def coinChange(self, coins: List[int], amount: int):
        dp = [float('inf')] * (amount + 1)
        # dp 存储的是总金额 这个要想到
        dp[0] = 0
        for i in range(amount + 1):
            for coin in coins:
                # 只有当硬币面额不大于要求面额数时，才能取该硬币
                if coin &lt;= i:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        if dp[amount] &lt;= amount:
            return dp[amount]
        else:
            return -1
</code></pre>
<h3 id="a-name-p718-a-LC-718-最长重复子数组"><a name="p718"></a> <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">LC-718 最长重复子数组</a></h3>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br>
示例：<br>
输入：<br>
A: [1,2,3,2,1]<br>
B: [3,2,1,4,7]<br>
输出：3<br>
解释：<br>
长度最长的公共子数组是 [3, 2, 1] 。</p>
<p><strong>转移方程：dp[i][j] = dp[i-1][j-1] + 1</strong></p>
<pre><code class="language-python">class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -&gt; int:
        if not nums1 or not nums2:
            return 0
        a, b = len(nums1), len(nums2)

        dp = [[0] * (a + 1) for _ in range(b + 1)]

        for i in range(1, b+1):
            for j in range(1, a+1):
                if nums1[j - 1] == nums2[i - 1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                # 子串需要严格相等
                # else:
                #     dp[i][j] = dp[i-1][j-1]
        return max([max(dp[i][:]) for i in range(len(dp))])
</code></pre>
<h3 id="a-name-p198-a-LC-198-打劫家舍"><a name="p198"></a> <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">LC-198 打劫家舍</a></h3>
<p><code>动态规划</code>, <code>递归</code></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>输入：[1,2,3,1]<br>
输出：4</p>
<p><strong>转移方程：dp[i] = max(nums[i] + dp[i-2], dp[i-1])</strong></p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        if len(nums) &lt;= 1:
            return nums[0]
        
        dp = [i for i in range(len(nums))]
        dp[0] = nums[0]
        dp[1] = max(nums[1], nums[0]) # dp[1] 取 1 和 2 中的 max
        for i in range(2, len(nums)):
            dp[i] = max(nums[i]+dp[i-2], dp[i-1])

        return dp[-1]
</code></pre>
<h3 id="a-name-p213-a-LC-213-打劫家舍2"><a name="p213"></a> <a href="https://leetcode-cn.com/problems/house-robber-ii//" target="_blank" rel="noopener">LC-213 打劫家舍2</a></h3>
<p><code>动态规划</code>, <code>递归</code><br>
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<p>输入：nums = [1,2,3,1]<br>
输出：4<br>
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>
     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p><strong>转移方程：dp[i] = max(dp[i-2] + nums[i], dp[i-1])</strong></p>
<pre><code class="language-python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        def sub_rob(nums,n) :
            dp = [0] * n 
            dp[0] = nums[0]
            dp[1] = max(nums[0],nums[1]) 
            for i in range(2,n):
                dp[i] = max(dp[i-2] + nums[i], dp[i-1])       
            return dp[-1] 

        n = len(nums)
        if n &lt;3:
            return max(nums)

        nums1 = nums[1:]
        nums2 = nums[:-1]
        
        result1 = sub_rob(nums1,n-1)
        result2 = sub_rob(nums2,n-1)

        return max(result1,result2)
</code></pre>
<h3 id="a-name-p62-a-LC-62-不同路径"><a name="p62"></a> <a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">LC-62 不同路径</a></h3>
<p><code>动态规划</code>, <code>递归</code><br>
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>
问总共有多少条不同的路径？</p>
<p>输入：m = 3, n = 2<br>
输出：3<br>
解释：<br>
从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下</li>
</ol>
<p><strong>转移方程： dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p>
<pre><code class="language-python">class Solution:
    def uniquePaths(self, m: int, n: int):
        if m &lt;=0 or n &lt;= 0:
            return 0
        dp = [[0] * n for _ in range(m)]
        # 外侧一圈要先初始化为1
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
</code></pre>
<h3 id="a-name-p63-a-LC-63-不同路径2"><a name="p63"></a> <a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LC-63 不同路径2</a></h3>
<p><code>动态规划</code>, <code>递归</code><br>
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>
输出：2<br>
解释：<br>
3x3 网格的正中间有一个障碍物。<br>
从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p><strong>转移方程： dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong><br>
<strong>if 有障碍物 then dp[i][j] = 0, 注意外圈有障碍物，则余下都为0，需要额外处理</strong></p>
<pre><code class="language-python">class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
        if not obstacleGrid:
            return 0
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])

        dp = [[0] * n for _ in range(m)]
        # 外侧一圈要先初始化为1
        for i in range(m):
            if obstacleGrid[i][0] == 1:
                for x in range(i, m):
                    dp[x][0] = 0
                break
            else:
                dp[i][0] = 1
        for j in range(n):
            if obstacleGrid[0][j] == 1:
                for x in range(j, n):
                    dp[0][x] = 0
                break
            else:
                dp[0][j] = 1
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
</code></pre>
<h3 id="a-name-p63-a-LC-64-最小路径和"><a name="p63"></a> <a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">LC-64 最小路径和</a></h3>
<p><code>动态规划</code>, <code>递归</code></p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>
说明：每次只能向下或者向右移动一步。</p>
<p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>
输出：7<br>
解释：因为路径 1→3→1→1→1 的总和最小。</p>
<p><strong>转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</strong><br>
注意贴边的一圈都只能从左到右，或者从上到下得到值</p>
<pre><code class="language-python">class Solution:
    def minPathSum(self, grid: List[List[int]]) -&gt; int:
        if not grid:
            return 0
        
        m = len(grid)
        n = len(grid[0])

        dp = [[0] * (n) for _ in range(m)]
        dp[0][0] = grid[0][0]
        for i in range(1, n):
            dp[0][i] = dp[0][i-1] + grid[0][i]
        for j in range(1, m):
            dp[j][0] = dp[j-1][0] + grid[j][0]

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        return dp[-1][-1]
</code></pre>
<h3 id="a-name-p152-a-LC-152-乘积最大子数组"><a name="p152"></a> <a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LC-152 乘积最大子数组</a></h3>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br>
示例 1:<br>
输入: [2,3,-2,4]<br>
输出: 6<br>
解释: 子数组 [2,3] 有最大乘积 6。</p>
<p><strong>转移方程：max_v = max(max_a * nums[i], nums[i], min_a * nums[i])</strong><br>
<strong>min_v = min(min_a * nums[i], nums[i], max_a * nums[i])</strong></p>
<p>乘积最大可能是负数乘负数，或者正数乘正数，所以需要维护2个队列</p>
<pre><code class="language-python">class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        # 乘积需要维护2个值，最大值和最小值
        if len(nums) == 1:
            return nums[0]
        max_a = nums[0]
        min_a = nums[0]
        res = nums[0]
        for i in range(1, len(nums)):
            max_v = max(max_a * nums[i], nums[i], min_a * nums[i])
            min_v = min(min_a * nums[i], nums[i], max_a * nums[i])
            res = max(max_v, res)
            max_a = max_v
            min_a = min_v
        return res
</code></pre>
<h3 id="a-name-p523-a-LC-523-连续的子数组和"><a name="p523"></a> <a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">LC-523 连续的子数组和</a></h3>
<p><code>前缀和</code><br>
给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组<br>
子数组大小 至少为 2 ，且<br>
子数组元素总和为 k 的倍数。<br>
如果存在，返回 true ；否则，返回 false 。<br>
如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。</p>
<p>示例 1：<br>
输入：nums = [23,2,4,6,7], k = 6<br>
输出：true<br>
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</p>
<p>看到子数组和求和问题的时候，要想到前缀和方法</p>
<pre><code class="language-python">class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -&gt; bool:
        # 前缀和+哈希表，查看是否有连续的一段元素的，和为k的倍数就行，同余定理，i%m - j%m = (i-j)%m
        n = len(nums)
        if n &lt; 2: return False

        # 记录前缀和，除以k的余数
        sub = [0] * (1 + len(nums))
        for i in range(len(nums)):
            sub[i+1] = (sub[i] + nums[i]) % k

        # 记录相同前缀和对k取余，记录所有余数相同的位置list
        dic = {}
        for idx, pre in enumerate(sub):
            print(pre)
            if pre not in dic.keys(): 
                dic[pre] = [idx]
            else:
                dic[pre].append(idx)

        # 查找是否存在一段， max - min &gt;= 2 来判断
        for k, v in dic.items():
            if max(v) - min(v) &gt;=2:
                return True
        return False
</code></pre>
<h3 id="a-name-p139-a-LC-139-单词拆分"><a name="p139"></a> <a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">LC-139 单词拆分</a></h3>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>
说明：<br>
拆分时可以重复使用字典中的单词。<br>
你可以假设字典中没有重复的单词。<br>
示例 1：<br>
输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>
输出: true<br>
解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p>
<p><strong>转移方程：dp[j] = dp[i] and s[i:j]</strong></p>
<pre><code class="language-python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True
        for i in range(n):
            for j in range(i+1, n+1):
                if dp[i] and s[i:j] in wordDict:
                    dp[j] = True
        return dp[-1]
</code></pre>
<h3 id="a-name-p264-a-LC-264-丑数2"><a name="p264"></a> <a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">LC-264 丑数2</a></h3>
<p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。<br>
丑数 就是只包含质因数 2、3 和/或 5 的正整数。<br>
示例 1：<br>
输入：n = 10<br>
输出：12<br>
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</p>
<p>方法一，利用堆排序，根据丑数定义，对前一个数以此乘以 [2, 3, 5]，不断加入到堆中。一头入堆，一头出堆，直到等于n结束。</p>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        hq = []
        heapq.heappush(hq, 1)
        used = set()
        used.add(1)
        ugly_factors = [2, 3, 5]

        for i in range(n):
            print(i)
            x = heapq.heappop(hq)
            if i == n-1:
                return x

            for u in ugly_factors:
                if x * u not in used:
                    used.add(x * u)
                    heapq.heappush(hq, x * u)
        return -1
</code></pre>
<p>方法二，动态规划三指针，三个指针起始指向 index = 0，更新时将3个指针分别乘以对应的 2，3，5；最小的值更新为下一个index，被选中的指针+1</p>
<p><strong>转移方程：dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)</strong></p>
<pre><code class="language-python">class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        dp = [1] * n
        p2, p3, p5 = 0, 0, 0
        for i in range(1, n, 1):
            p2_num, p3_num, p5_num = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
            min_num = min(p2_num, p3_num, p5_num)
            dp[i] = min_num
            if min_num == p2_num: p2 += 1
            if min_num == p3_num: p3 += 1
            if min_num == p5_num: p5 += 1
        return dp[-1]
</code></pre>
<h3 id="a-name-p279-a-LC-279-完全平方数"><a name="p279"></a> <a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">LC-279 完全平方数</a></h3>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。<br>
示例 1：<br>
输入：n = 12<br>
输出：3<br>
解释：12 = 4 + 4 + 4</p>
<p>示例 2：<br>
输入：n = 13<br>
输出：2<br>
解释：13 = 4 + 9</p>
<p><strong>转移方程: dp[num] = min(dp[num], dp[num - i * i] + 1)</strong></p>
<pre><code class="language-python">class Solution:
    def numSquares(self, n: int) -&gt; int:
        dp = [1] * (n + 1)
        dp[0] = 0
        for num in range(1, n + 1):
            dp[num] = num
            tmp = []
            for i in range(1, int(num ** 0.5) + 1):
                tmp.append(dp[num - i**2] + 1)
            dp[num] = min(tmp)
        return dp[-1]
</code></pre>
<h3 id="a-name-p309-a-LC-309-最佳买卖股票时机含冷冻期"><a name="p309"></a> <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">LC-309 最佳买卖股票时机含冷冻期</a></h3>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>
示例:<br>
输入: [1,2,3,0,2]<br>
输出: 3<br>
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<p>股票类题目运用状态机，设定3个维度：1. 天数、2. 次数、3. 状态（持有、不持有、不持有冷冻），此题没有次数，只需要构建2维数组</p>
<p><strong>转移方程：</strong></p>
<pre><code class="language-python"># 持有
dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])
# 不持有，不冷冻
dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
# 不持有，冷冻
dp[i][2] = max(dp[i-1][1], dp[i-1][2])
</code></pre>
<pre><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        if len(prices) &lt;= 1:
            return 0
        
        # 天数、次数、状态：持有 不持有 冷冻
        dp = [[0 for j in range(3)] for _ in range(len(prices))]
        dp[0][0] = -prices[0]

        for i in range(1, len(prices)):
            for j in range(3):
                # 持有
                dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])
                # 不持有 不冷冻
                dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
                # 不持有 冷冻
                dp[i][2] = max(dp[i-1][1], dp[i-1][2])

        return max(dp[-1][1], dp[-1][2])
</code></pre>
<h3 id="a-name-p188-a-LC-188-买卖股票的最佳时机-IV"><a name="p188"></a> <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">LC-188 买卖股票的最佳时机 IV</a></h3>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1：<br>
输入：k = 2, prices = [2,4,1]<br>
输出：2<br>
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4 - 2 = 2。</p>
<p>重点：</p>
<ul>
<li>第 1 天就买入需要进行初始化 - prices[0]</li>
<li>交易成功 1 次需要更新 k</li>
</ul>
<p><strong>转移方程：</strong><br>
<strong>dp[i][0][k]=max(dp[i−1][0][k],dp[i−1][1][k]+prices[i])</strong><br>
<strong>dp[i][1][k]=max(dp[i−1][1][k],dp[i−1][0][k−1]−prices[i])</strong></p>
<pre><code class="language-python">class Solution:
    def maxProfit(self, k: int, prices: List[int]) -&gt; int:
        if len(prices) &lt;= 1 or k &lt;= 0:
            return 0
        
        dp = [[[i for i in range(2)] for j in range(k+1)] for n in range(len(prices))]

        # 补第一天就买入的case, k=0，交易不会成功
        for i in range(1, k+1):
            dp[0][i][1] = -prices[0]

        for i in range(1, len(prices)):
            for j in range(1, k+1):
                dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])
                dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])
        return max([j[0] for i in dp for j in i])
</code></pre>
<h3 id="a-name-p343-a-LC-343-整数拆分"><a name="p343"></a> <a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">LC-343 整数拆分</a></h3>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br>
示例 1:<br>
输入: 2<br>
输出: 1<br>
解释: 2 = 1 + 1, 1 × 1 = 1。</p>
<p>示例 2:<br>
输入: 10<br>
输出: 36<br>
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p>
<p><strong>转移函数：</strong></p>
<pre><code class="language-python">class Solution:
    def integerBreak(self, n: int) -&gt; int:
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n + 1):
            for j in range(i):
                dp[i] = max(dp[i], j * (i-j), j * dp[i-j])
        return dp[-1]
</code></pre>
<h3 id="a-name-p416-a-LC-416-分割等和子集"><a name="p416"></a> <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">LC-416 分割等和子集</a></h3>
<p>给你一个 只包含正整数 的 非空 数组 nums。<br>
请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>
示例 1：<br>
输入：nums = [1,5,11,5]<br>
输出：true<br>
解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p>
<p>动态规划，01 背包问题</p>
<p><strong>转移方程：</strong><br>
<strong>dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i]]</strong></p>
<pre><code class="language-python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        sum_num = sum(nums)
        if sum_num % 2 == 1:
            return False
        target = sum_num // 2
        dp = [[False] * (target + 1) for i in range(len(nums))]
        for i in range(len(nums)):
            dp[i][0] = True
        for i in range(len(nums)):
            for j in range(1, target + 1):
                if nums[i] == j:
                    dp[i][j] = True
                if nums[i] &lt; j:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i]]
                # 比目标值大，直接拿上一位
                if nums[i] &gt; j:
                    dp[i][j] = dp[i-1][j]
        # print(dp)
        return dp[-1][-1]
</code></pre>
<h3 id="a-name-p42-a-LC-42-接雨水"><a name="p42"></a> <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LC-42 接雨水</a></h3>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出：6<br>
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<p><strong>关键方程：res += min(l_max[i], r_max[i]) - height[i]</strong></p>
<pre><code class="language-python">class Solution:
    def trap(self, height: List[int]):
        # 核心思想： res += min(l_max[i], r_max[i]) - height[i];
        if not height:
            return 0
        
        left_p = 0
        right_p = len(height) - 1
        left_max = 0
        right_max = 0
        res = 0
        while left_p &lt;= right_p:
            left_max = max(left_max, height[left_p])
            right_max = max(right_max, height[right_p])

            if left_max &lt; right_max:
                res += left_max - height[left_p]
                left_p += 1
            else:
                res += right_max - height[right_p]
                right_p -= 1
        return res
</code></pre>
<p>也可以用dp来解，<strong>转移方程left_max[i] = max(height[i], left_max[i-1])</strong><br>
<strong>right_max[i] = max(height[i], right_max[i + 1])</strong></p>
<pre><code class="language-python">class Solution:
    def trap(self, height: List[int]) -&gt; int:
        # 核心思想： res += min(l_max[i], r_max[i]) - height[i];
        if not height:
            return 0
       
        left_max = [height[0]] + [0] * (len(height) - 1)
        right_max = [0] * (len(height) - 1) + [height[-1]]

        for i in range(1, len(height)):
            left_max[i] = max(height[i], left_max[i-1])
        for i in range(len(height) - 2, -1 , -1):
            right_max[i] = max(height[i], right_max[i + 1])
        
        res = 0
        for j in range(len(height)):
            ans = min(left_max[j], right_max[j]) - height[j]
            res += ans
        return res
</code></pre>
<h3 id="a-name-p32-a-LC-32-最长有效括号"><a name="p32"></a> <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">LC-32 最长有效括号</a></h3>
<p>给你一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br>
输入：s = “)()())”<br>
输出：4<br>
解释：最长有效括号子串是 “()()”</p>
<p>用堆来保存括号的index</p>
<pre><code class="language-python">class Solution:
    def longestValidParentheses(self, s: str) -&gt; int:
        stack = [-1]
        res = 0
        for i, j in enumerate(s):
            if j == &quot;(&quot;:
                stack.append(i)
            else:
                stack.pop()
                if stack:
                    res = max(res, i - stack[-1])
                else:
                    stack.append(i)
        return result
</code></pre>
<h3 id="a-name-p72-a-LC-72-编辑距离"><a name="p72"></a> <a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">LC-72 编辑距离</a></h3>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>
你可以对一个单词进行如下三种操作：<br>
插入一个字符<br>
删除一个字符<br>
替换一个字符</p>
<p>示例1：<br>
输入：word1 = “horse”, word2 = “ros”<br>
输出：3<br>
解释：<br>
horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>
rorse -&gt; rose (删除 ‘r’)<br>
rose -&gt; ros (删除 ‘e’)</p>
<p><strong>转移方程：if word1[i] == word2[j] then dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1])</strong><br>
<strong>else dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)</strong></p>
<p>初始化第一行和第一列，想到二维矩阵，dp[i][j]由dp[i-1][j-1]表示替换操作，dp[i][j]由dp[i-1][j]表示删除操作+1，dp[i][j]由dp[i][j-1]表示插入操作+1<br>
dp[i][0] 和 dp[0][j] 初始化为对应单词和空字符串之间的编辑距离。</p>
<pre><code class="language-python">class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        if len(word1) == 0:
            return len(word2)
        if len(word2) == 0:
            return len(word1)
        
        dp = [[0] * (len(word1) + 1) for _ in range(len(word2) + 1)]
        for i in range(1, len(dp)):
            dp[i][0] = i
        for j in range(1, len(dp[0])):
            dp[0][j] = j

        for i in range(1, len(dp)):
            for j in range(1, len(dp[0])):
                if word2[i-1] == word1[j-1]:
                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1])
                else:
                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)
        return dp[-1][-1]
</code></pre>
<h1>树</h1>
<h3 id="a-name-p103-a-LC-103-二叉树锯齿形便利"><a name="p103"></a> <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LC-103 二叉树锯齿形便利</a></h3>
<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ \<br>
9  20<br>
/  \<br>
15   7</p>
<p>返回锯齿形层序遍历如下：<br>
[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]</p>
<p>BFS和DFS，BFS一定使用队列，本题由于有奇偶行的区别，考虑使用双端队列；DFS递归参数要代上层号。</p>
<pre><code class="language-python"># BFS
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        queue = deque()
        queue.append(root)
        flag = 1
        res = []
        while queue:
            level = deque() # 每层node存放
            for i in range(len(queue)):
                item = queue.popleft() 
                # 弹出后 做2件事：
                # 1. 存入 level queue
                if flag % 2 == 1:
                    level.append(item.val)
                else:
                    level.appendleft(item.val)
                # 2. 左右子节点存入 queue
                if item.left:
                    queue.append(item.left)
                if item.right:
                    queue.append(item.right)
            res.append(level)
            flag += 1
        return res
</code></pre>
<pre><code class="language-python"># DFS
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        res = []
        def recursive(root, index):
            # 递归要把完成的程序栈 return
            if not root:
                return
            if index &gt; len(res):
                res.append(deque())
            if index % 2 == 1:
                res[index-1].append(root.val)
            else:
                res[index-1].appendleft(root.val)
            recursive(root.left, index + 1)
            recursive(root.right, index + 1)
        recursive(root, 1)
        return [list(item) for item in res]
</code></pre>
<h3 id="a-name-p103-a-LC-102-二叉树的层序遍历"><a name="p103"></a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LC-102 二叉树的层序遍历</a></h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：<br>
二叉树：[3,9,20,null,null,15,7],<br>
3<br>
/ \<br>
9  20<br>
/  \<br>
15   7</p>
<p>返回其层序遍历结果：</p>
<p>[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]</p>
<p>层序遍历BFS一般步骤：</p>
<ol>
<li>边界判断</li>
<li>新建deque，加入root</li>
<li>queue循环当前queue中的长度，并新建每一层的结果存储集level</li>
<li>2件事，加入level结果，加入queue以便做下一次遍历</li>
</ol>
<pre><code class="language-python"># BFS
class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []

        queue = deque()
        queue.append(root)

        res = []
        while queue:
            level = []
            for i in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res
</code></pre>
<p>深度遍历DFS一般步骤：</p>
<ol>
<li>判断边界</li>
<li>写遍历函数体，递归要return函数栈</li>
<li>对每一个root节点，做2件事：加入到res对应的层中，前序遍历以此递归</li>
</ol>
<pre><code class="language-python"># DFS
class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        res = []
        def recursive(root, index):
            if not root:
                return 
            if index &gt; len(res):
                res.append([])
            res[index - 1].append(root.val)
            recursive(root.left, index + 1)
            recursive(root.right, index + 1)
        recursive(root, 1)
        return res
</code></pre>
<h3 id="a-name-p107-a-LC-107-二叉树的层序遍历2"><a name="p107"></a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">LC-107 二叉树的层序遍历2</a></h3>
<p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ \<br>
9  20<br>
/  \<br>
15   7<br>
返回其自底向上的层序遍历为：</p>
<p>[<br>
[15,7],<br>
[9,20],<br>
[3]<br>
]</p>
<p>和102唯一的区别就是存放最终结果的时候是倒序，自底向上累计。</p>
<pre><code class="language-python">class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        res = []
        def recursive(root, index):
            if not root:
                return 
            if index &gt; len(res):
                res.insert(0, [])
            res[len(res)-index].append(root.val) # 注意append的index是最大行数-当前index=0
            recursive(root.left, index + 1)
            recursive(root.right, index + 1)
        recursive(root, 1)
        return res
</code></pre>
<h3 id="a-name-p236-a-LC-236-二叉树的最近公共祖先"><a name="p236"></a> <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="noopener">LC-236 二叉树的最近公共祖先</a></h3>
<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出：3<br>
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
<pre><code class="language-python">class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode':
        # 后序遍历
        if root == p or root == q or root == None:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        # 得到该节点对应的左右节点后，要决定根据状态返回 root、left、right 哪个节点
        if left and right:
            return root
        if left == None and right:
            return right
        elif right == None and left:
            return left
        else:
            return None
</code></pre>
<h3 id="a-name-p98-a-LC-98-验证二叉搜索树"><a name="p98"></a> <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LC-98 验证二叉搜索树</a></h3>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br>
假设一个二叉搜索树具有如下特征：<br>
节点的左子树只包含小于当前节点的数。<br>
节点的右子树只包含大于当前节点的数。<br>
所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>解释: 输入为: [5,1,4,null,null,3,6]。<br>
根节点的值为 5 ，但是其右子节点值为 4 。</p>
<p>中序遍历，BST重要特征是中序遍历后的数组是按顺序的</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        if not root: return True
        self.pre = None
        def midorder(root): 
            left , right= True , True
            if root.left: left = midorder(root.left)
            if self.pre and self.pre.val &gt;= root.val :#前一个节点的值是否小于当前节点的值
                return False
            self.pre = root#记录前一个节点
            if root.right: right = midorder(root.right)
            return left and right
        return midorder(root)
</code></pre>
<h3 id="a-name-p199-a-LC-199-二叉树右视图"><a name="p199"></a> <a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">LC-199 二叉树右视图</a></h3>
<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br>
输入: [1,2,3,null,5,null,4]<br>
输出: [1,3,4]</p>
<p>BFS，层序遍历，遍历到最右边，加入到结果集中。</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        if not root:
            return []
        queue = deque()
        queue.append(root)

        res = []
        while queue:
            n = len(queue)
            for i in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                if i == (n - 1):
                    res.append(node.val)
        return res
</code></pre>
<p>DFS, 前序遍历，右节点先行</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        res = []
        def dfs(root, deep):
            if not root:
                return 

            if deep == len(res):
                res.append(root.val)
            deep += 1

            dfs(root.right, deep)
            dfs(root.left, deep)
        dfs(root, 0)
        return res
</code></pre>
<h3 id="a-name-p101-a-LC-101-对称二叉树"><a name="p101"></a> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">LC-101 对称二叉树</a></h3>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>
1<br>
/ \<br>
2   2<br>
/ \ / \<br>
3  4 4  3</p>
<p>DFS，构造递归函数，入参是左右2个的节点。</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root:
            return True
        
        def helper(left, right):
            if not left and not right:
                return True
            if not left or not right or left.val != right.val:
                return False
            
            ans = helper(left.left, right.right) and helper(left.right, right.left)
            return ans
        return helper(root.left, root.right)
</code></pre>
<h3 id="a-name-p105-a-LC-105-从前序与中序遍历序列构造二叉树"><a name="p105"></a> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">LC-105 从前序与中序遍历序列构造二叉树</a></h3>
<p>给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。<br>
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>
Output: [3,9,20,null,null,15,7]</p>
<ol>
<li>前序遍历确定根节点</li>
<li>中序遍历中拿到根节点index，分为左右子树</li>
<li>递归作为前序和中序的输入</li>
<li>代码整体是前序遍历<br>
将大问题拆解成子问题</li>
</ol>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if len(inorder) == 0:
            return None
        
        # 跟节点
        root = TreeNode(preorder[0])
        # 中间节点
        mid = inorder.index(preorder[0])
        # 左子树
        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])
        # 右子树
        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])
        return root
</code></pre>
<h3 id="a-name-p112-a-LC-112-路径总和"><a name="p112"></a> <a href="https://leetcode-cn.com/problems/path-sum//" target="_blank" rel="noopener">LC-112 路径总和</a></h3>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。<br>
叶子节点 是指没有子节点的节点。</p>
<p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>
输出：true</p>
<p>输入：root = [1,2], targetSum = 0<br>
输出：false</p>
<p>DFS 递归</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool:

        if not root:
            return False
        
        def dfs(root, target):
            if not root:
                return False
            if not root.left and not root.right:
                if root.val == target:
                    return True
                else:
                    return False
            l = dfs(root.left, target - root.val)
            r = dfs(root.right, target - root.val)
            return l or r
        return dfs(root, targetSum)
</code></pre>
<h3 id="a-name-p113-a-LC-113-路径总和-II"><a name="p113"></a> <a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">LC-113 路径总和 II</a></h3>
<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。<br>
叶子节点 是指没有子节点的节点。</p>
<p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>
输出：[[5,4,11,2],[5,8,4,5]]</p>
<p>DFS，不需要回溯，没有需要维护的可变状态，不断递归就可</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; List[List[int]]:
        if not root:
            return []
        
        def dfs(root, target, path):
            if not root:
                return
            if not root.left and not root.right:
                if target - root.val == 0:
                    path.append(root.val)
                    res.append(path)
            dfs(root.left, target - root.val, path + [root.val])
            dfs(root.right, target - root.val, path + [root.val])

        res = []
        dfs(root, targetSum, [])
        return res
</code></pre>
<h3 id="a-name-p124-a-LC-124-二叉树中的最大路径和"><a name="p124"></a> <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">LC-124 二叉树中的最大路径和</a></h3>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br>
路径和 是路径中各节点值的总和。<br>
给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p>输入：root = [1,2,3]<br>
输出：6<br>
解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: TreeNode) -&gt; int:
        self.res = float('-inf')

        def helper(root):
            if not root:
                return 0
            
            left = helper(root.left)
            right = helper(root.right)
            # inner 内部路径
            self.res = max(self.res, root.val + left + right)
            # outside 需要返回给父节点的外部路径
            inner_max = max(left, right) + root.val
            # inner_max &lt;=0 时返回 0
            if inner_max &lt;= 0:
                return 0
            else:
                return inner_max
        helper(root)
        return self.res
</code></pre>
<h3 id="a-name-p129-a-LC-129-求根节点到叶节点数字之和"><a name="p129"></a> <a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">LC-129 求根节点到叶节点数字之和</a></h3>
<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>
每条从根节点到叶节点的路径都代表一个数字：<br>
例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>
计算从根节点到叶节点生成的 所有数字之和.叶节点 是指没有子节点的节点。</p>
<p>输入：root = [4,9,0,5,1]<br>
输出：1026<br>
解释：<br>
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>
从根到叶子节点路径 4-&gt;0 代表数字 40<br>
因此，数字总和 = 495 + 491 + 40 = 1026</p>
<p>前序遍历，先处理root.val * 10</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: TreeNode) -&gt; int:
        res = 0
        def helper(root, tmp):
            if not root:
                return 0
            # 前序遍历
            tmp = tmp * 10 + root.val;
            if not root.left and not root.right:
                return tmp
            return helper(root.left, tmp) + helper(root.right, tmp)

        return helper(root, 0)
</code></pre>
<h3 id="a-name-p958-a-LC-958-二叉树的完全性检验"><a name="p958"></a> <a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">LC-958 二叉树的完全性检验</a></h3>
<p>给定一个二叉树，确定它是否是一个完全二叉树。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png" alt=""><br>
输入：[1,2,3,4,5,6]<br>
输出：true<br>
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。<br>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png" alt=""><br>
输入：[1,2,3,4,5,null,7]<br>
输出：false<br>
解释：值为 7 的结点没有尽可能靠向左侧。</p>
<pre><code class="language-python"># class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isCompleteTree(self, root: TreeNode) -&gt; bool:
        if not root:
            return False
        queue = deque()
        queue.append(root)
        while queue:
            for i in range(len(queue)):
                item = queue.popleft()
                if not item:
                    print(set(queue))
                    if set(queue) == {None}:
                        return True
                    else:
                        return False
                queue.append(item.left)
                queue.append(item.right)
</code></pre>
<h3 id="a-name-p104-a-LC-104-二叉树的最大深度"><a name="p104"></a> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LC-104 二叉树的最大深度</a></h3>
<p>给定一个二叉树，找出其最大深度。<br>
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>
说明: 叶子节点是指没有子节点的节点。<br>
示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，</p>
<p>后续遍历</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        def helper(root, deep):
            if not root:
                return 0
            l = helper(root.left, deep)
            r = helper(root.right, deep)
            return 1 + max(l, r)
        return helper(root, 0)
</code></pre>
<h3 id="a-name-p226-a-LC-226-反转二叉树"><a name="p226"></a> <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">LC-226 反转二叉树</a></h3>
<pre><code class="language-python">class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return 
        tmp = root.left
        root.left = root.right
        root.right = tmp
        self.invertTree(root.left) 
        self.invertTree(root.right)
        return root
</code></pre>
<h3 id="a-name-p114-a-LC-114-二叉树展开成链表"><a name="p114"></a> <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list" target="_blank" rel="noopener">LC-114 二叉树展开成链表</a></h3>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>
展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p>输入：root = [1,2,5,3,4,null,6]<br>
输出：[1,null,2,null,3,null,4,null,5,null,6]</p>
<ul>
<li>后序遍历，递归</li>
<li>左节点换到右节点</li>
<li>右节点接到左节点右边</li>
</ul>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        def dfs(root):
            if not root:
                return None
            # 后序遍历
            dfs(root.left)
            dfs(root.right)

            # 拿到左右节点
            l = root.left
            r = root.right

            # 对于root来说左节点置空，原左节点置右
            root.left = None
            root.right = l

            p = root
            # 遍历当前右节点到最后，右节点街上
            while p.right:
                p = p.right
            p.right = r
        dfs(root)
</code></pre>
<h3 id="a-name-p230-a-LC-230-二叉树搜索树中的第k个小的元素"><a name="p230"></a> <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">LC-230 二叉树搜索树中的第k个小的元素</a></h3>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。<br>
输入：root = [5,3,6,2,4,null,null,1], k = 3<br>
输出：3</p>
<p>BST 搜索树，中序遍历可以得到排序后的序列</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        res = []
        def inorder(root):
            if not root:
                return []
            inorder(root.left)
            res.append(root.val)
            inorder(root.right)
        inorder(root)
        return res[k-1]
</code></pre>
<h3 id="a-name-p662-a-LC-662-二叉树最大宽度"><a name="p662"></a> <a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">LC-662 二叉树最大宽度</a></h3>
<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。<br>
每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
<p>输入:<br>
1<br>
/ <br>
3   2<br>
/     \<br>
5       9<br>
/         <br>
6           7<br>
输出: 8<br>
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。</p>
<p>层次遍历</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        
        queue = [(root, 1)]
        res = 1

        while queue:
            for _ in range(len(queue)):
                item = queue.pop(0)
                node = item[0]
                index = item[1]

                if node.left:
                    queue.append((node.left, index * 2))
                if node.right:
                    queue.append((node.right, index * 2 + 1))
            if queue:
                res = max(res, 1 + queue[-1][1] - queue[0][1])
        return res
</code></pre>
<h1>链表</h1>
<h3 id="a-name-p206-a-LC-206-反转链表"><a name="p206"></a> <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LC-206 反转链表</a></h3>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>输入：head = [1,2,3,4,5]<br>
输出：[5,4,3,2,1]</p>
<pre><code class="language-python">class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return head
        # 后续节点
        last = self.reverseList(head.next)
        # 1. 前序节点反转
        head.next.next = head
        # 2. 砍掉本身的next指针
        head.next = None
        return last
</code></pre>
<pre><code class="language-python">class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre, cur = None, head
        while cur:
            nxt = cur.next
            # 接到pre后面
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
</code></pre>
<h3 id="a-name-p25-a-LC-25-K个一组反转链表"><a name="p25"></a> <a href="https://https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LC-25 K个一组反转链表</a></h3>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>
k 是一个正整数，它的值小于或等于链表的长度。<br>
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>输入：head = [1,2,3,4,5], k = 3<br>
输出：[3,2,1,4,5]</p>
<pre><code class="language-python">class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:
        def reverse(left, right):
            pre, cur = left, left.next
            # pre 收集结果
            first, last = pre, cur
            while cur != right:
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
                
            first.next = pre
            last.next = right
            return last

        dummy = ListNode(-1)
        dummy.next = head
        left, right = dummy, head
        cnt = 0
        while right:
            cnt += 1
            right = right.next
            if cnt % k == 0:
                left = reverse(left, right)
        return dummy.next
</code></pre>
<p>运用翻转链表的子模块，在主模块里的first和last，first 始终表示进行翻转组的前一个，last 表示最终的最后一个节点，其实也就是起始翻转的第一个节点。<br>
K个一组翻转链表要点：</p>
<ul>
<li>构建虚拟头结点，涉及几个一组、快慢、双指针问题，都要涉及到2个指正前进的问题</li>
<li>翻转部分子函数，传入的应该是翻转组的前一个和后一个节点，这样可以串联最后的结果</li>
<li>子模型是翻转链表，pre实则是收集最终结果，last是该子模块的最后一个节点，也是下一个迭代的起点</li>
</ul>
<h3 id="a-name-p92-a-LC-92-反转链表2"><a name="p92"></a> <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LC-92 反转链表2</a></h3>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>
输出：[1,4,3,2,5]</p>
<p>链表头插法解题</p>
<pre><code class="language-python">class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -&gt; ListNode:
        dummy_node = ListNode(-1)
        dummy_node.next = head

        pre = dummy_node
        for i in range(left-1):
            pre = pre.next

        cur = pre.next
        # 头插法
        for i in range(right - left):
            nxt = cur.next
            cur.next = nxt.next
            nxt.next = pre.next
            pre.next = nxt
        return dummy_node.next
</code></pre>
<p>头插法要点：</p>
<ul>
<li>得到 pre, cur 和 nxt</li>
<li>cur next 指针指向 nxt 后一个</li>
<li>nxt next 指针指向 pre 的 next 即之前的头结点</li>
<li>pre next 指向 nxt</li>
</ul>
<h3 id="a-name-p21-a-LC-21-合并两个有序链表"><a name="p21"></a> <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LC-21 合并两个有序链表</a></h3>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>
输入：l1 = [1,2,4], l2 = [1,3,4]<br>
输出：[1,1,2,3,4,4]</p>
<p>链表递归，实则就是回溯</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode):
        if not l1: return l2
        if not l2: return l1

        if l1.val &lt; l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            # 回溯
            return l1
        else:
            l2.next = self.mergeTwoLists(l2.next, l1)
            # 回溯
            return l2
</code></pre>
<h3 id="a-name-p23-a-LC-23-合并k个有序链表"><a name="p23"></a> <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LC-23 合并k个有序链表</a></h3>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>
请你将所有链表合并到一个升序链表中，返回合并后的链表。<br>
示例 1：<br>
输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>
输出：[1,1,2,3,4,4,5,6]<br>
解释：链表数组如下：<br>
[<br>
1-&gt;4-&gt;5,<br>
1-&gt;3-&gt;4,<br>
2-&gt;6<br>
]<br>
将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p>方法一，逐个做合并2个有序链表。</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
        x = None
        for i in lists:
            x = self.mergeTwoLists(x, i)
        return x

    # 合并 2 个有序链表模板
    def mergeTwoLists(self, l1: ListNode, l2: ListNode):
        if not l1: return l2
        if not l2: return l1

        if l1.val &lt; l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            # 回溯
            return l1
        else:
            l2.next = self.mergeTwoLists(l2.next, l1)
            # 回溯
            return l2
</code></pre>
<p>方法二，归并排序</p>
<pre><code class="language-python">class Solution:
    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
        if not lists:return 
        n = len(lists)
        return self.merge(lists, 0, n-1)
    def merge(self,lists, left, right):
        if left == right:
            return lists[left]
        mid = left + (right - left) // 2
        # left, mid
        l1 = self.merge(lists, left, mid)
        # mid + 1, right
        l2 = self.merge(lists, mid+1, right)
        # 分拆到最后，再做 2 个链表合并
        return self.mergeTwoLists(l1, l2)
    def mergeTwoLists(self,l1, l2):
        if not l1:return l2
        if not l2:return l1
        if l1.val &lt; l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
</code></pre>
<h3 id="a-name-p141-a-LC-141-环形链表"><a name="p141"></a> <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LC-141 环形链表</a></h3>
<p>给定一个链表，判断链表中是否有环。</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>
输出：true<br>
解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>简单题，快慢指针，相遇即有环</p>
<pre><code class="language-python">class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        dummy = ListNode(-1)
        dummy.next = head
        fast, slow = dummy.next, dummy
        while fast != slow:
            if not fast or not fast.next:
                return False
            fast = fast.next.next
            slow = slow.next
        return True
</code></pre>
<h3 id="a-name-p142-a-LC-142-环形链表2"><a name="p142"></a> <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LC-142 环形链表2</a></h3>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>
输出：返回索引为 1 的链表节点<br>
解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>f = 2s (快指针是慢指针速度的2倍)<br>
f = s + nk （快指针比慢指针多走了n次环，环是k）<br>
s = nk，快指针重置为head，相遇即为环的入口</p>
<pre><code class="language-python">class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        fast, slow = head, head
        while True: 
            if not fast or not fast.next:
                return None
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
        
        fast = head
        while fast != slow:
            fast = fast.next
            slow = slow.next
        return slow
</code></pre>
<h3 id="a-name-p160-a-LC-160-相交链表"><a name="p160"></a> <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">LC-160 相交链表</a></h3>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br>
图示两个链表在节点 c1 开始相交：</p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>
输出：Intersected at ‘8’<br>
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<pre><code class="language-python">class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        a = headA
        b = headB
        while a != b:
            if a:
                a = a.next
            else: a = headB
        
            if b:
                b = b.next
            else: b = headA
        return a
</code></pre>
<h3 id="a-name-p19-a-LC-19-删除链表的倒数第-N-个结点"><a name="p19"></a> <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">LC-19 删除链表的倒数第 N 个结点</a></h3>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>
进阶：你能尝试使用一趟扫描实现吗？<br>
输入：head = [1,2,3,4,5], n = 2<br>
输出：[1,2,3,5]<br>
<img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt=""></p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dummy = ListNode(0)
        dummy.next = head 
        #step1: 快指针先走n步
        slow, fast = dummy, dummy
        for _ in range(n):
            fast = fast.next 
        #step2: 快慢指针同时走，直到fast指针到达尾部节点，此时slow到达倒数第N个节点的前一个节点
        while fast and fast.next:
            slow, fast = slow.next, fast.next 
        #step3: 删除节点，并重新连接
        slow.next = slow.next.next 
        return dummy.next 
</code></pre>
<h3 id="a-name-p143-a-LC-143-重排链表"><a name="p143"></a> <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">LC-143 重排链表</a></h3>
<p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br>
L0 → L1 → … → Ln-1 → Ln <br>
请将其重新排列后变为：<br>
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …<br>
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>输入: head = [1,2,3,4]<br>
输出: [1,4,2,3]</p>
<p>输入: head = [1,2,3,4,5]<br>
输出: [1,5,2,4,3]</p>
<p>三步：找中点；反转链表；合并有序链表</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: ListNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify head in-place instead.
        &quot;&quot;&quot;
        if not head:
            return None
        mid = self.find_mid(head)
        l1 = head
        l2 = mid.next
        # 切断
        mid.next = None
        l2 = self.reverse_list(l2)
        return self.merge(l1, l2)

    def find_mid(self, head):
        if head is None or head.next is None: 
            return head
        slow,fast = head, head.next
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        return slow

    def reverse_list(self, head):
        pre, cur = None, head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
    
    def merge(self, l1, l2):
        head = l1
        while l2:
            l1_nxt = l1.next
            l2_nxt = l2.next
            l1.next = l2
            l2.next = l1_nxt
            l1 = l1_nxt
            l2 = l2_nxt
        return head
</code></pre>
<h3 id="a-name-p234-a-LC-234-回文链表"><a name="p234"></a> <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">LC-234 回文链表</a></h3>
<p>请判断一个链表是否为回文链表.<br>
输入: 1-&gt;2-&gt;2-&gt;1<br>
输出: true</p>
<p>3种方法：</p>
<ul>
<li>把链表变成数组，用双指针，缺点额外空间</li>
<li>链表后序递归</li>
<li>快慢双指针找中点后，后半段反转链表</li>
</ul>
<pre><code class="language-python"> # 第二种
 class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        self.left = head
        def traverse(right):
            if not right:
                return True
            res = traverse(right.next)
            if res and self.left.val == right.val: 
                res = True
            else: 
                res = False
            self.left = self.left.next
            return res
        return traverse(head)
</code></pre>
<pre><code class="language-python"># 第三种
class Solution:
   def isPalindrome(self, head: ListNode) -&gt; bool:
       if not head or not head.next:
           return True

       # 找中点
       fast = head
       slow = head
       while fast and fast.next:
           slow = slow.next
           fast = fast.next.next
       if not fast:
           mid = slow
       else:
           mid = slow.next

       # 反转链表
       right_head = mid
       pre = None
       cur = right_head
       while cur:
           nxt = cur.next
           cur.next = pre
           pre = cur
           cur = nxt

       # 比较相等
       right = pre
       left = head
       while right and left:
           if right.val != left.val:
               return False
           right = right.next
           left = left.next
       return True
</code></pre>
<h3 id="a-name-p148-a-LC-148-排序链表"><a name="p148"></a> <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LC-148 排序链表</a></h3>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。<br>
进阶：<br>
你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？<br>
示例 1：<br>
输入：head = [4,2,1,3]<br>
输出：[1,2,3,4]</p>
<p>nlogn 复杂度，需要考虑 快排、归并、堆等</p>
<pre><code class="language-python">class Solution:
    # 归并排序
    def sortList(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next: 
            return head
        left_end = self.find_mid(head)
        mid = left_end.next 
        left_end.next = None
        # 左边 None 结束，右边 mid 开始
        left, right = self.sortList(head), self.sortList(mid)
        return self.merged(left, right)
    # 快慢指针查找链表中点
    def find_mid(self, head):
        if head is None or head.next is None: return head
        slow,fast = head, head.next
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        return slow
    # 合并有序链表
    def merged(self, left, right):
        res = ListNode()
        h = res
        while left and right:
            if left.val &lt; right.val: 
                h.next= left
                left = left.nex
            else: 
                h.next = right
                right = right.next
            h = h.next
        # 判断 left 和 right 是否是 None
        h.next = left if left else right
        return res.next
</code></pre>
<h3 id="a-name-p83-a-LC-83-删除排序链表中的重复元素"><a name="p83"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">LC-83 删除排序链表中的重复元素</a></h3>
<p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>
返回同样按升序排列的结果链表。</p>
<p>输入：head = [1,1,2,3,3]<br>
输出：[1,2,3]</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        dummy = ListNode(-10000)
        dummy.next = head
        p = dummy
        # p 落后 head 一个节点位置
        while head:
            if p.val != head.val:
                p.next = head
                p = p.next
            head = head.next
        p.next = None
        return dummy.next
</code></pre>
<h3 id="a-name-p24-a-LC-24-两两交换链表中的节点"><a name="p24"></a> <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">LC-24 两两交换链表中的节点</a></h3>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>
示例 1：<br>
输入：head = [1,2,3,4]<br>
输出：[2,1,4,3]</p>
<p>递归：</p>
<pre><code class="language-python">class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return headx
        newHead = head.next
        head.next = self.swapPairs(newHead.next)
        newHead.next = head
        return newHead
</code></pre>
<p>迭代</p>
<pre><code class="language-python">class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        dummyHead = ListNode(0)
        dummyHead.next = head
        temp = dummyHead
        while temp.next and temp.next.next:
            node1 = temp.next
            node2 = temp.next.next
            temp.next = node2
            node1.next = node2.next
            node2.next = node1
            temp = node1
        return dummyHead.next
</code></pre>
<h3 id="a-name-p328-a-LC-328-奇偶链表"><a name="p328"></a> <a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">LC-328 奇偶链表</a></h3>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。<br>
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>
示例 2:<br>
输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>
输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p>
<pre><code class="language-python"># class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        
        odd = head
        even = head.next
        evenhead = head.next

        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        
        odd.next = evenhead
        return head
</code></pre>
<h3 id="a-name-p61-a-LC-61-旋转链表"><a name="p61"></a> <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">LC-61 旋转链表</a></h3>
<p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。<br>
示例 1：<br>
<img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt=""><br>
输入：head = [1,2,3,4,5], k = 2<br>
输出：[4,5,1,2,3]</p>
<p>分解为3个题：1.长度，2.末尾第n个节点，3.切割链表</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:
        length = 0
        cur = head
        while cur:
            length += 1
            cur = cur.next
        if length &lt; 1: # 注意
            return head
        k = k % length
        if k == 0: 
            return head
        dummy = ListNode(0)
        dummy.next = head
        fast, slow = dummy, dummy
        for _ in range(k):
            fast = fast.next
        while fast.next:
            slow = slow.next
            fast = fast.next
        newHead = slow.next
        slow.next = None
        fast.next = head
        return newHead
</code></pre>
<h3 id="a-name-p86-a-LC-86-分隔链表"><a name="p86"></a> <a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">LC-86 分隔链表</a></h3>
<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。<br>
你应当 保留 两个分区中每个节点的初始相对位置。<br>
示例 1：<br>
输入：head = [1,4,3,2,5,2], x = 3<br>
输出：[1,2,2,4,3,5]</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: ListNode, x: int) -&gt; ListNode:
        small, large = ListNode(), ListNode()
        sm = small
        lg = large
        while head:
            if head.val &lt; x:
                sm.next = head
                sm = sm.next
            else:
                lg.next = head
                lg = lg.next
            head = head.next
        lg.next = None
        sm.next = large.next
        return small.next
</code></pre>
<h3 id="a-name-p82-a-LC-82-删除排序链表中的重复元素2"><a name="p82"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">LC-82 删除排序链表中的重复元素2</a></h3>
<p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>
返回同样按升序排列的结果链表。</p>
<p>输入：head = [1,2,3,3,4,4,5]<br>
输出：[1,2,5]</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy = ListNode(None)
        dummy.next = head
        p = dummy

        while head and head.next:
            if p.next.val != head.next.val:
                p = p.next
                head = head.next
            else:
                while head and head.next and p.next.val==head.next.val:
                    head = head.next
                # p 的 next 要指定 head 的下一个
                p.next = head.next
                head = head.next
        return dummy.next
</code></pre>
<p>组织 tail，2 步 head next 避免 插入相同的</p>
<pre><code class="language-python">class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        tail = dummy = ListNode(-1)
        while head:
            if head.next == None or head.val != head.next.val:
                tail.next = head;
                tail = tail.next
            while head.next and head.val == head.next.val:
                head = head.next
            head = head.next
        tail.next = None
        return dummy.next
</code></pre>
<h1>数学</h1>
<h3 id="a-name-p2-a-LC-2-两数相加"><a name="p2"></a> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">LC-2 两数相加</a></h3>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>
请你将两个数相加，并以相同形式返回一个表示和的链表。<br>
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>
输出：[7,0,8]<br>
解释：342 + 465 = 807.</p>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>
输出：[8,9,9,9,0,0,0,1]</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:

        head = dummy = ListNode()
        curry = 0
        sum = 0
        res = 0
        # 当l1和l2都为None时，需要检查curry进位符是否还为1
        while curry or l1 or l2:
            if l1: 
                l1_val = l1.val 
            else: 
                l1_val = 0
            if l2: 
                l2_val = l2.val 
            else: 
                l2_val = 0
            sum = l1_val + l2_val + curry
            res = sum % 10
            curry = sum // 10
            dummy.next = ListNode(res)
            dummy, l1, l2 = dummy.next, l1.next if l1 else None, l2.next if l2 else None
        return head.next
</code></pre>
<p>链表需要时刻检查链表是否为None，新建2个dummy节点，一个随迭代往后，一个指向开头用于返回结果。</p>
<h3 id="a-name-p8-a-LC-8-字符串转换整数-atoi"><a name="p8"></a> <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">LC-8 字符串转换整数 (atoi)</a></h3>
<p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：<br>
读入字符串并丢弃无用的前导空格<br>
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>
将前面步骤读入的这些数字转换为整数（即，“123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>
返回整数作为最终结果。</p>
<p>输入：s = &quot;   -42&quot;<br>
输出：-42<br>
解释：<br>
第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）<br>
^<br>
第 2 步：&quot;   -42&quot;（读入 ‘-’ 字符，所以结果应该是负数）<br>
^<br>
第 3 步：&quot;   -42&quot;（读入 “42”）<br>
^<br>
解析得到整数 -42 。<br>
由于 “-42” 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</p>
<p>需要严格注意这个读入的顺序</p>
<pre><code class="language-python">class Solution:
    def myAtoi(self, s: str) -&gt; int:
        str=s.lstrip()
        if len(str)==0:
            return 0
        # 不断改写
        last=0
        #如果有符号设置起始位置2，其余的为1
        i=2 if str[0]=='-'or str[0]=='+'  else 1
        #循环，直到无法强转成int，跳出循环
        while i &lt;= len(str):
            try:
                last=int(str[:i])
                i+=1
            except:
                break
        if last&lt;-2**31:
            return -2147483648
        if last&gt;2**31-1:
            return 2147483647
        return last
</code></pre>
<p>启发另一种索引方式，索引最后一个位置，而非索引对应位置，这样可以和题目要求对应，作用到下一个之前</p>
<h3 id="a-name-p8-a-LC-50-Pow-x-n"><a name="p8"></a> <a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">LC-50 Pow(x, n)</a></h3>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。<br>
示例 1:<br>
输入：x = 2.00000, n = 10<br>
输出：1024.00000</p>
<p>示例 3：<br>
输入：x = 2.00000, n = -2<br>
输出：0.25000<br>
解释：2-2 = 1/22 = 1/4 = 0.25</p>
<pre><code class="language-python">class Solution:
    def myPow(self, x: float, n: int) -&gt; float:
        def quickMul(N):
            if N == 0:
                return 1.0
            y = quickMul(N // 2)
            return y * y if N % 2 == 0 else y * y * x
        
        return quickMul(n) if n &gt;= 0 else 1.0 / quickMul(-n)
</code></pre>
<h3 id="a-name-p43-a-LC-43-字符串相乘"><a name="p43"></a> <a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">LC-43 字符串相乘</a></h3>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br>
示例 1:<br>
输入: num1 = “2”, num2 = “3”<br>
输出: “6”</p>
<p>示例 2:<br>
输入: num1 = “123”, num2 = “456”<br>
输出: “56088”</p>
<pre><code class="language-python">class Solution:
    def multiply(self, num1: str, num2: str) -&gt; str:
        n1 = len(num1)
        n2 = len(num2)
        num2_int = int(num2)
        res = 0
        #n1 按位倒序与n2相乘，拿到对应位置作为10的power
        for i in range(n1-1, -1, -1):
            weight = n1- 1 - i
            num1_new = int(num1[i])
            res += num1_new * 10 ** weight * num2_int
        return str(res)
</code></pre>
<h3 id="a-name-p470-a-LC-470-用-Rand7-实现-Rand10"><a name="p470"></a> <a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">LC-470 用 Rand7() 实现 Rand10()</a></h3>
<p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。<br>
不要使用系统的 Math.random() 方法.<br>
示例 1:<br>
输入: 1<br>
输出: [7]<br>
示例 2:<br>
输入: 2<br>
输出: [8,4]</p>
<p>小数表示大数：(rand7()-1) × 7 + rand7() = result<br>
(rand_x() - 1) × origin_number + rand_y()<br>
可以等概率的生成[1, X * Y]范围的随机数</p>
<pre><code class="language-python">class Solution:
    def rand10(self):
        &quot;&quot;&quot;
        :rtype: int
        &quot;&quot;&quot;
        # 已知 rand_N() 可以等概率的生成[1, N]范围的随机数
        # 那么：
        # (rand_X() - 1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数
        # 即实现了 rand_XY()
        while True:
            num = (rand7() - 1) * 7 + rand7()
            if num &lt;= 40:
                return num % 10 + 1
</code></pre>
<h3 id="a-name-p12-a-LC-12-整数转罗马数字"><a name="p12"></a> <a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">LC-12 整数转罗马数字</a></h3>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br>
字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给你一个整数，将其转为罗马数字。</p>
<p>哈希表</p>
<pre><code class="language-python">class Solution:
    def intToRoman(self, num: int) -&gt; str:
        hashmap = {1000:'M', 
            900:'CM', 
            500:'D', 
            400:'CD', 
            100:'C', 
            90:'XC', 
            50:'L', 
            40:'XL', 
            10:'X', 
            9:'IX', 
            5:'V', 
            4:'IV', 
            1:'I'
        }
        res = ''

        for i in hashmap.keys():
            count = num // i
            if count &gt; 0:
                res += ''.join([hashmap[i]] * count)
                num = num % i
        return res
</code></pre>
<h1>滑动窗口</h1>
<p><strong>滑动窗口通用模板：</strong></p>
<pre><code class="language-python">need, window = {}, {}
for c in t:
    记录need            # 视具体问题而定，用于判断窗口包含的字串是否满足题目要求
left, right = 0, 0      # 初始化左右指针，窗口是左闭右开区间，[left, right)
while right &lt; len(s):
    c = s[right]
    right += 1
    更新窗口数据
    while 满足窗口收缩条件：
        记录优化后的结果
        d = s[left]
        left += 1
        更新窗口数据
return 结果
</code></pre>
<h3 id="a-name-p3-a-LC-3-无重复字符的最长子串"><a name="p3"></a> <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LC-3 无重复字符的最长子串</a></h3>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。<br>
示例 1:<br>
输入: s = “abcabcbb”<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        res = 0
        window = dict()
        left, right = 0, 0
        if len(s) == 1:
            return 1
        if len(s) &lt; 1:
            return 0

        while right &lt; len(s):
            cur = s[right]
            if cur in window.keys():
                window[cur] += 1
            else:
                window[cur] = 1
            right += 1
            while window[cur] &gt; 1:
                curl = s[left]
                if curl in window.keys():
                    window[curl] -= 1
                left += 1

            # 判断并更新结果
            if max(window.values()) == 1:
                cnt = 0
                for key, val in window.items():
                    if val == 1:
                        cnt += 1
                res = max(res, cnt)
        return res
</code></pre>
<h3 id="a-name-p76-a-LC-76-最小覆盖子串"><a name="p76"></a> <a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">LC-76 最小覆盖子串</a></h3>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>
输入：s = “ADOBECODEBANC”, t = “ABC”<br>
输出：“BANC”</p>
<p>滑动窗口的基本模式：</p>
<ul>
<li>初始化的 min_len 为 inf float</li>
<li>记住只有在need字典中的key才会影响最终结果，不在的话就直接right++或者left–</li>
<li>match标志位表示这一位的need和window的key是不是值相等</li>
</ul>
<pre><code class="language-python">class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        # 初始化
        start, min_len = 0, float('Inf')
        left, right = 0, 0
        need = Counter(t)
        window = collections.defaultdict(int)
        match = 0

        # right 
        while right &lt; len(s):
            # 拿出 right 指针
            c1 = s[right]
            if need[c1] &gt; 0:
                # 匹配后match+1
                window[c1] += 1
                if window[c1] == need[c1]:
                    match += 1
            right += 1

            while match == len(need):
                # 更新结果
                if right - left &lt; min_len:
                    min_len = right - left
                    start = left
                # 优化结果，更新window字典
                c2 = s[left]
                if need[c2] &gt; 0:
                    window[c2] -= 1
                    if window[c2] &lt; need[c2]:
                        match -= 1
                left += 1
        return s[start:start+min_len] if min_len != float('Inf') else &quot;&quot;
</code></pre>
<h3 id="a-name-p239-a-LC-239-滑动窗口最大值"><a name="p239"></a> <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LC-239 滑动窗口最大值</a></h3>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>
返回滑动窗口中的最大值。<br>
示例 1：<br>
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>
输出：[3,3,5,5,6,7]<br>
解释：<br>
滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br>
1 [3  -1  -3] 5  3  6  7       3<br>
1  3 [-1  -3  5] 3  6  7       5<br>
1  3  -1 [-3  5  3] 6  7       5<br>
1  3  -1  -3 [5  3  6] 7       6<br>
1  3  -1  -3  5 [3  6  7]      7</p>
<p>单调队列，新的元素，检查是否大于最后一个，满足pop掉末尾的，上浮；判断第一个是否不在窗口，popleft。</p>
<pre><code class="language-python">class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:
        from collections import deque
        window = deque()
        res = []
        for i in range(len(nums)):
            while window and nums[i] &gt; nums[window[-1]]:
                window.pop()
            window.append(i)

            if window[0] &lt;= i - k:
                window.popleft()
            
            if i - k + 1 &gt;= 0:
                res.append(nums[window[0]])
        return res
</code></pre>
<h1>二分查找</h1>
<p><strong>二分查找模型：</strong></p>
<pre><code class="language-python"># 常规
def binarySearch(nums, target):
    if len(nums) == 0: return -1
    left = 0
    right = len(nums) - 1
    while(left &lt;= right):
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] &gt; target:
            right = mid - 1
        elif nums[mid] &lt; target:
            left = mid + 1
    return -1

# 最左边界, right = mid，返回left
def binarySearch(nums, target):
    if len(nums) == 0: return -1
    left, right = 0, len(nums) # 注意
    while(left &lt; right): # 注意
        mid = left + (right - left) // 2
        if nums[mid] == target:
            right = mid # 注意
        elif nums[mid] &gt; target:
            right = mid # 注意
        elif nums[mid] &lt; target:
            left = mid + 1
    return left

# 最右边界，
def binarySearch(nums, target):
    if len(nums) == 0: return -1
    left, right = 0, len(nums) # 注意
    while(left &lt; right): # 注意
        mid = left + (right - left) // 2
        if nums[mid] == target:
            left = mid + 1 # 注意
        elif nums[mid] &lt; target:
            left = mid + 1
        elif nums[mid] &gt; target:
            right = mid # 注意
    return left

</code></pre>
<h3 id="a-name-p33-a-LC-33-搜索旋转排序数组"><a name="p33"></a> <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">LC-33 搜索旋转排序数组</a></h3>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>
在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>示例 1：<br>
输入：nums = [4,5,6,7,0,1,2], target = 0<br>
输出：4</p>
<p>示例 2：<br>
输入：nums = [4,5,6,7,0,1,2], target = 3<br>
输出：-1</p>
<pre><code class="language-python">class Solution:
    def search(self, nums: List[int], target: int):
        left, right = 0, len(nums) - 1
        while left &lt;= right:

            mid = (left + right) // 2

            if nums[mid] == target:
                return mid
            
            if nums[0] &lt;= nums[mid]:
                if nums[0] &lt;= target and nums[mid] &gt; target:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] &lt; target and nums[-1] &gt;= target:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
</code></pre>
<h3 id="a-name-p162-a-LC-163-寻找峰值"><a name="p162"></a> <a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">LC-163 寻找峰值</a></h3>
<p>峰值元素是指其值大于左右相邻值的元素。<br>
给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>
你可以假设 nums[-1] = nums[n] = -∞ 。</p>
<p>示例 2：<br>
输入：nums = [1,2,1,3,5,6,4]<br>
输出：1 或 5<br>
解释：你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5，其峰值元素为 6。</p>
<pre><code class="language-python">class Solution:
    def findPeakElement(self, nums: List[int]) -&gt; int:
        if len(nums) &lt;= 2:
            return nums.index(max(nums))

        left = 0
        right = len(nums) - 1

        while left &lt; right:
            mid = (left + right) // 2

            if nums[mid] &gt; nums[mid + 1]:
                right = mid
            else:
                left = mid + 1
        return left
</code></pre>
<h3 id="a-name-p240-a-LC-240-搜索二维矩阵-II"><a name="p240"></a> <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">LC-240 搜索二维矩阵 II</a></h3>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>
每行的元素从左到右升序排列。<br>
每列的元素从上到下升序排列。<br>
 <br>
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br>
输出：true</p>
<p>Trick: 以右上角的值作为起点，大于target往下走，小于target往左走。</p>
<pre><code class="language-python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
        if len(matrix) &lt;= 1 and len(matrix[0]) &lt;= 1:
            return matrix[0][0] == target

        row, col = 0, len(matrix[0]) - 1
        while 0 &lt;= row &lt; len(matrix) and 0 &lt;= col &lt; len(matrix[0]):
            if target &lt; matrix[row][col]:
                col -= 1
            elif target &gt; matrix[row][col]:
                row += 1
            else:
                return True
        return False
</code></pre>
<h3 id="a-name-p31-a-LC-31-下一个排列"><a name="p31"></a> <a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">LC-31 下一个排列</a></h3>
<p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。<br>
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。</p>
<p>示例 1：<br>
输入：nums = [1,2,3]<br>
输出：[1,3,2]<br>
示例 2：<br>
输入：nums = [3,2,1]<br>
输出：[1,2,3]</p>
<p>需要原地排序，</p>
<ol>
<li>找到第一个 左边 &lt; 右边 的左边index i</li>
<li>从尾部开始遍历，找到第一个 右边 &gt; 左边的 index j</li>
<li>交换 nums[i] 和 nums[j]</li>
<li>对于 i+1 部分整体反转</li>
</ol>
<pre><code class="language-python">class Solution:
    def nextPermutation(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        i = len(nums) - 2
        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:
            i -= 1

        if i &gt;= 0: # 这个 i &gt;= 0 很难想到，原地排序不满足就不动
            j = len(nums) - 1
            while j &gt;= 0 and nums[i] &gt;= nums[j]:
                j -= 1
            
            nums[i], nums[j] = nums[j], nums[i]

        left, right = i + 1, len(nums) - 1
        while left &lt;= right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
</code></pre>
<h1>回溯</h1>
<p><strong>回溯通用模板：</strong></p>
<pre><code class="language-python">result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
</code></pre>
<h3 id="a-name-p46-a-LC-46-全排列"><a name="p46"></a> <a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LC-46 全排列</a></h3>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br>
示例 1：<br>
输入：nums = [1,2,3]<br>
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<pre><code class="language-python">class Solution:
    def permute(self, nums: List[int]):
        if not nums:
            return []
        # 最终结果集   
        res = []
        def dfs(remain,path):
            if not remain:
                res.append(path)
                return
            size = len(remain)
            for _ in range(size):
                path.append(remain.pop(0))
                dfs(remain,path[:])
                remain.append(path.pop())
        dfs(nums,[])
        return res
</code></pre>
<p>回溯法的终极条件是，全局维护一个可变的状态，所以需要不断的选择和撤销操作。<br>
但是如果不存在可变状态，只是作为函数的传参，就不需要撤销操作了，一切都是函数的递归调用。如下</p>
<pre><code class="language-python">class Solution(object):
    # DFS
    def permute(self, nums):
        res = []
        self.dfs(nums, [], res)
        return res

    def dfs(self, nums, path, res):
        if not nums:
            res.append(path)
            # return # backtracking
        for i in range(len(nums)):
            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)
</code></pre>
<h3 id="a-name-p78-a-LC-78-子集"><a name="p78"></a> <a href="https://leetcode-cn.com/problems/subsets/submissions/" target="_blank" rel="noopener">LC-78 子集</a></h3>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br>
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br>
示例 1：<br>
输入：nums = [1,2,3]<br>
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
<pre><code class="language-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res = []

        def dfs(path, i):
            res.append(path)
            # 不能重复 用j+1向后遍历 没有回溯 直接是dfs
            for j in range(i, len(nums)):
                dfs(path+[nums[j]], j+1)
                
        dfs([], 0)
        return res
</code></pre>
<p>清楚版：</p>
<pre><code class="language-python">class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res = []
        def dfs(i, remain, path):
            res.append(path)
            size = len(remain)
            for j in range(i, size):
                path.append(nums[j])
                # 下一次迭代 j+1
                dfs(j+1, remain, path[:])
                path.pop()
        dfs(0,nums,[])
        return res
</code></pre>
<h3 id="a-name-p77-a-LC-77-组合"><a name="p77"></a> <a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">LC-77 组合</a></h3>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>
你可以按 任何顺序 返回答案。<br>
示例 1：<br>
输入：n = 4, k = 2<br>
输出：<br>
[<br>
[2,4],<br>
[3,4],<br>
[2,3],<br>
[1,2],<br>
[1,3],<br>
[1,4],<br>
]</p>
<pre><code class="language-python">class Solution:
    def combine(self, n: int, k: int) -&gt; List[List[int]]:
        nums = [i for i in range(1, n+1)]
        res = []

        def dfs(i, path):
            if len(path) == k:
                res.append(path)
                return
            
            for j in range(i, len(nums)):
                # 压入
                path.append(nums[j])
                # 迭代，当前index往后一位开始迭代
                dfs(j+1, path[:])
                # 弹出
                path.pop()
        dfs(0, [])
        return res
</code></pre>
<p>上述三题为所有回溯题都会沿用的模板，<strong>不要去想回溯的过程</strong>，直接调用模板</p>
<h3 id="a-name-p39-a-LC-39-组合总和"><a name="p39"></a> <a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">LC-39 组合总和</a></h3>
<p>给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p>
<p>输入: candidates = [2,3,6,7], target = 7<br>
输出: [[7],[2,2,3]]</p>
<p>输入: candidates = [2,3,5], target = 8<br>
输出: [[2,2,2,2],[2,3,3],[3,5]]</p>
<p>三要素：</p>
<ol>
<li>path 记录走过的节点</li>
<li>remain 剩余的array，用index索引，或者不断pop remain的数组</li>
<li>判断结果符合，可以借助排序来避免剪枝</li>
</ol>
<pre><code class="language-python">class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        res = []
        candidates.sort()
        if target &lt; min(candidates):
            return res

        def dfs(start, path, gap):
            if gap == 0:
                res.append(path)
                return 

            if gap &lt; min(candidates):
                return 

            for i in range(start, len(candidates)):
                path.append(candidates[i])
                dfs(i, path[:], gap - candidates[i])
                path.pop()
        dfs(0, [], target)
        return res
</code></pre>
<h3 id="a-name-p22-a-LC-22-括号生成"><a name="p22"></a> <a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">LC-22 括号生成</a></h3>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>
有效括号组合需满足：左括号必须以正确的顺序闭合。<br>
示例 1：<br>
输入：n = 3<br>
输出：[“((()))”,“(()())”,“(())()”,“()(())”,“()()()”]</p>
<p>DFS + 剪枝，不需要维护一个状态:</p>
<pre><code class="language-python">class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        if n == 0:
            return []

        res = []
        def dfs(cur, left, right):
            if left == n and right == n:
                res.append(cur)
            if left &lt; n:
                dfs(cur + &quot;(&quot;, left + 1, right)
            # 如果右括号比左括号多，一定不能构成有效括号
            if left &gt; right:
                dfs(cur + &quot;)&quot;, left, right + 1)
        dfs(&quot;&quot;, 0, 0)
        return res
</code></pre>
<p>回溯，需要维护一个path状态</p>
<pre><code class="language-python">class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        
        def backtrace(left, right, path):
            if left == n  and right == n:
                res.append(''.join(path))
                return 
            
            if left &lt; n:
                path.append('(')
                backtrace(left + 1, right, path[:])
                path.pop()
            
            if left &gt; right:
                path.append(&quot;)&quot;)
                backtrace(left, right + 1, path[:])
                path.pop()
            
        res = []
        backtrace(0, 0, [])
        return res
</code></pre>
<h3 id="a-name-p79-a-LC-79-单词搜索"><a name="p79"></a> <a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">LC-79 单词搜索</a></h3>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>输入：board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCCED”<br>
输出：true</p>
<pre><code class="language-python">class Solution:
    def exist(self, board: List[List[str]], word: str) -&gt; bool:

        def dfs(i, j, k):

            if k == len(word) - 1 and 0&lt;=i&lt;=a-1 and 0&lt;=j&lt;=b-1 and word[k] == board[i][j]:
                return True

            if not 0&lt;=i&lt;=a-1 or not 0&lt;=j&lt;=b-1 or word[k] != board[i][j]:
                return False

            board[i][j] = ''
            
            i1 = dfs(i-1, j, k+1)
            i2 = dfs(i+1, j, k+1)
            j1 = dfs(i, j-1, k+1)
            j2 = dfs(i, j+1, k+1)
            # 这步退格很关键
            board[i][j] = word[k]
            return i1 or i2 or j1 or j2
        
        a, b = len(board), len(board[0])
        
        for i in range(0, a):
            for j in range(0, b):
                if dfs(i, j, 0):
                    return True

        return False
            
</code></pre>
<h3 id="a-name-p47-a-LC-47-全排列2"><a name="p47"></a> <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">LC-47 全排列2</a></h3>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。<br>
示例 1：<br>
输入：nums = [1,1,2]<br>
输出：<br>
[[1,1,2],<br>
[1,2,1],<br>
[2,1,1]]</p>
<p>示例 2：<br>
输入：nums = [1,2,3]<br>
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>回溯，全排列类问题，需要对数组排序<br>
新增used array用来记录index是否被访问的状态。状态回退时，不仅要回退path，used也需要回退</p>
<pre><code class="language-python">class Solution:
    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:
        res = []
        used = [0] * len(nums)
        # 排序
        nums.sort()
        if not nums:
            return []
        def dfs(path):
            if len(path) == len(nums):
                res.append(path[:])
                return 
            
            for i in range(len(nums)):
                if used[i] &gt; 0:
                    continue
                # 同层前一个数相同，且未被用到，则需要跳过
                if i &gt; 0 and nums[i] == nums[i-1] and not used[i-1]:
                    continue
                path.append(nums[i])
                used[i] = 1
                dfs(path)
                # 状态回退
                path.pop()
                used[i] = 0
        
        dfs([])
        return res
</code></pre>
<h3 id="a-name-p40-a-LC-47-全组合2"><a name="p40"></a> <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">LC-47 全组合2</a></h3>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>
candidates 中的每个数字在每个组合中只能使用一次。<br>
注意：解集不能包含重复的组合。 <br>
示例 1:<br>
输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>
输出:<br>
[<br>
[1,1,6],<br>
[1,2,5],<br>
[1,7],<br>
[2,6]<br>
]</p>
<p>排列组合题，先排序；因为同个数字只能用一次，数字相同时，取最后一个。</p>
<pre><code class="language-python">class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        if not candidates:
            return []
        candidates.sort()
        n = len(candidates)
        res = []
        
        def backtrack(i, tmp_sum, tmp_list):
            if tmp_sum == target:
                res.append(tmp_list)
                return 
            for j in range(i, n):
                if tmp_sum + candidates[j]  &gt; target : break
                if j &gt; i and candidates[j] == candidates[j-1]:continue
                backtrack(j + 1, tmp_sum + candidates[j], tmp_list + [candidates[j]])
        backtrack(0, 0, [])    
        return res
</code></pre>
<h1>DFS/BFS</h1>
<h3 id="a-name-p200-a-LC-200-岛屿数量"><a name="p200"></a> <a href="https://leetcode-cn.com/problems/number-of-island" target="_blank" rel="noopener">LC-200 岛屿数量</a></h3>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>
此外，你可以假设该网格的四条边均被水包围。<br>
示例 1：<br>
输入：grid = [<br>
[“1”,“1”,“1”,“1”,“0”],<br>
[“1”,“1”,“0”,“1”,“0”],<br>
[“1”,“1”,“0”,“0”,“0”],<br>
[“0”,“0”,“0”,“0”,“0”]<br>
]<br>
输出：1</p>
<p>DFS</p>
<pre><code class="language-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        rows = len(grid)
        cols = len(grid[0])
        def dfs(grid, i, j):
            if i &gt;= rows or i &lt; 0 or j &gt;= cols or j &lt; 0 or grid[i][j] == '0':
                return 
            grid[i][j] = '0'
            dfs(grid, i, j+1)
            dfs(grid, i, j-1)
            dfs(grid, i+1, j)
            dfs(grid, i-1, j)
        count = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == '1':
                    dfs(grid, i, j)
                    count += 1
        return count
</code></pre>
<p>BFS 借助队列</p>
<pre><code class="language-python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        #bfs
        from collections import deque
        def bfs(grid, i, j):
            queue = deque([[i, j]])
            while queue:
                l = queue.popleft()
                x, y = l[0], l[1]
                if 0 &lt;= x &lt; len(grid) and 0 &lt;= y &lt; len(grid[0]) and grid[x][y] == '1':
                    grid[x][y] = '0'
                    queue.extend([[x+1, y], [x-1, y], [x, y+1], [x, y-1]])
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    bfs(grid, i, j)
                    count += 1
        return count
</code></pre>
<h3 id="a-name-p695-a-LC-695-岛屿的最大面积"><a name="p695"></a> <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">LC-695 岛屿的最大面积</a></h3>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。<br>
一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0)<br>
示例 1:<br>
[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,1,1,0,1,0,0,0,0,0,0,0,0],<br>
[0,1,0,0,1,1,0,0,1,0,1,0,0],<br>
[0,1,0,0,1,1,0,0,1,1,1,0,0],<br>
[0,0,0,0,0,0,0,0,0,0,1,0,0],<br>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>
[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p>
<p>BFS, 增加面积的计数</p>
<pre><code class="language-python">class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:
        from collections import deque
        def bfs(grid, i, j):
            queue = deque([[i, j]])
            area = 0
            while queue:
                l = queue.popleft()
                x, y = l[0], l[1]
                if 0&lt;=x&lt;len(grid) and 0&lt;=y&lt;len(grid[0]) and grid[x][y] == 1:
                    grid[x][y] = 0
                    area += 1
                    queue.extend([[x-1, y], [x+1, y], [x, y-1], [x, y+1]])
            return area
        max_area = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    max_area = max(bfs(grid, i, j), max_area)
        return max_area
</code></pre>
<h3 id="a-name-p394-a-LC-394-字符串解码"><a name="p394"></a> <a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">LC-394 字符串解码</a></h3>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4]的输入。<br>
示例 1：<br>
输入：s = “3[a]2[bc]”<br>
输出：“aaabcbc”<br>
示例 2：<br>
输入：s = “3[a2[c]]”<br>
输出：“accaccacc”</p>
<pre><code class="language-python">class Solution:
    def decodeString(self, s: str) -&gt; str:
        stack, res, multi = [], &quot;&quot;, 0
        for c in s:
            print(res)
            if c == '[':
                # 遇到 [ 暂存结果和数字
                stack.append([multi, res])
                res, multi = &quot;&quot;, 0
            elif c == ']':
                # 遇到 ] pop 组装
                cur_multi, last_res = stack.pop()
                res = last_res + cur_multi * res
            elif '0' &lt;= c &lt;= '9':
                multi = multi * 10 + int(c)            
            else:
                res += c
        return res
</code></pre>
<h3 id="a-name-p207-a-LC-207-课程表"><a name="p207"></a> <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">LC-207 课程表</a></h3>
<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。<br>
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。<br>
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<p>输入：numCourses = 2, prerequisites = [[1,0]]<br>
输出：true<br>
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</p>
<p>拓扑排序BFS步骤（最开始的先入队列）</p>
<ol>
<li>新建入度表，没有入度说明没有先修要求；新建邻接矩阵，表示 先修 -&gt; 后修</li>
<li>入度为 0 的 index 入队列</li>
<li>出队列，总数 -1，对应后修课程入度 -1，判断是否为0，为0继续入队。</li>
<li>最终判断是否将所有课程遍历结束</li>
</ol>
<pre><code class="language-python">class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        indegrees = [0] * numCourses
        adjacency = [[] for _ in range(numCourses)]
        queue = deque()
        for cur, pre in prerequisites:
            indegrees[cur] += 1
            # 学完之后可学的课程
            adjacency[pre].append(cur)
            
        # 放入没有入度的节点
        for i in range(len(indegrees)):
            if not indegrees[i]:
                queue.append(i)
        while queue:
            pre = queue.popleft()
            numCourses -= 1
            for cur in adjacency[pre]:
                indegrees[cur] -= 1
                if not indegrees[cur]:
                    queue.append(cur)
        return not numCourses
</code></pre>
<p>DFS：</p>
<pre><code class="language-python">class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        def dfs(i, adjacency, flags):
            if flags[i] == -1: return True
            if flags[i] == 1: return False
            flags[i] = 1
            for j in adjacency[i]:
                if not dfs(j, adjacency, flags): return False
            flags[i] = -1
            return True

        adjacency = [[] for _ in range(numCourses)]
        flags = [0 for _ in range(numCourses)]
        for cur, pre in prerequisites:
            adjacency[pre].append(cur)
        for i in range(numCourses):
            if not dfs(i, adjacency, flags): return False
        return True
</code></pre>
<h3 id="a-name-p106-a-LC-106-从中序与后序遍历序列构造二叉树"><a name="p106"></a> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">LC-106 从中序与后序遍历序列构造二叉树</a></h3>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。<br>
注意: 你可以假设树中没有重复的元素。<br>
例如，给出<br>
中序遍历 inorder = [9,3,15,20,7]<br>
后序遍历 postorder = [9,15,7,20,3]</p>
<ol>
<li>在后续遍历找到root头结点</li>
<li>将中序遍历mid节点前后切开</li>
<li>继续左右递归</li>
</ol>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:
        if len(inorder) == 0:
            return None
        root = TreeNode(postorder[-1])
        mid = inorder.index(postorder[-1])
        # left
        root.left = self.buildTree(inorder[:mid], postorder[:mid])
        # right
        root.right = self.buildTree(inorder[mid+1:], postorder[mid:-1])
        return root
</code></pre>
<h1>字符串</h1>
<h3 id="a-name-p151-a-LC-151-翻转字符串里的单词"><a name="p151"></a> <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">LC-151 翻转字符串里的单词</a></h3>
<p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。<br>
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。<br>
请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p>
<p>说明：<br>
输入字符串 s 可以在前面、后面或者单词间包含多余的空格。<br>
翻转后单词间应当仅用一个空格分隔。<br>
翻转后的字符串中不应包含额外的空格。</p>
<p>输入：s = &quot;  hello world  &quot;<br>
输出：“world hello”<br>
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。</p>
<pre><code class="language-python">class Solution:
    def reverseWords(self, s: str) -&gt; str:
        tmp = []
        res = []
        for word in s.strip().split(' '):
            if len(word.strip()) &gt;= 1:
                tmp.append(word.strip())

        for i in range(len(tmp)):
            res.append(tmp[len(tmp) - i - 1])
        return ' '.join(res)
</code></pre>
<p>直接写就好了</p>
<h3 id="a-name-p165-a-LC-165-比较版本号"><a name="p165"></a> <a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">LC-165 比较版本号</a></h3>
<p>给你两个版本号 version1 和 version2 ，请你比较它们。<br>
版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。<br>
比较版本号时，请按从左到右的顺序依次它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。<br>
返回规则如下：<br>
如果 version1 &gt; version2 返回 1，<br>
如果 version1 &lt; version2 返回 -1，<br>
除此之外返回 0。</p>
<p>转int后，pop掉末尾的0</p>
<pre><code class="language-python">class Solution:
    def compareVersion(self, version1: str, version2: str) -&gt; int:
        v1 = [int(item) for item in version1.split('.')]
        v2 = [int(item) for item in version2.split('.')]
        # 弹出0
        while len(v1) &gt; 1 and v1[-1] == 0: v1.pop()
        while len(v2) &gt; 1 and v2[-1] == 0: v2.pop()
        index = 0
        while index &lt; min(len(v1), len(v2)):
            if v1[index] &gt; v2[index]: return 1
            elif v1[index] &lt; v2[index]: return -1
            else: index += 1
        if len(v1) &gt; len(v2): return 1
        elif len(v1) &lt; len(v2): return -1
        else: return 0
</code></pre>
<h3 id="a-name-p93-a-LC-93-复原ip地址"><a name="p93"></a> <a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">LC-93 复原ip地址</a></h3>
<p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。<br>
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。<br>
例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>
示例 1：<br>
输入：s = “25525511135”<br>
输出：[“255.255.11.135”,“255.255.111.35”]</p>
<pre><code class="language-python">class Solution:
    def restoreIpAddresses(self, s: str) -&gt; List[str]:
        if len(s) &lt; 4 or len(s)&gt; 12:
            return []
        
        res = []

        def dfs(remain, path):
            if len(path) == 4 and not remain:
                res.append('.'.join(path))
                return

            for i in range(0, min(3, len(remain)), 1):
                ans = remain[0:i+1]
                if int(ans) &gt; 255 or len(str(int(ans))) != len(ans):
                    continue
                if i &gt;= len(remain):
                    dfs([], path + [ans])
                else:
                    dfs(remain[i+1:], path + [ans])
            
        dfs(s, [])
        return res
</code></pre>
<h3 id="a-name-p227-a-LC-227-基本计算器2"><a name="p227"></a> <a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">LC-227 基本计算器2</a></h3>
<p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。<br>
示例 1：<br>
输入：s = “3+2*2”<br>
输出：7</p>
<pre><code class="language-python">class Solution:
    def calculate(self, s: str) -&gt; int:
        n = len(s)
        stack = []
        preSign = '+'
        num = 0
        for i in range(n):
            if s[i] != ' ' and s[i].isdigit():
                num = num * 10 + int(s[i])
            if i == n - 1 or s[i] in '+-*/':
                if preSign == '+':
                    stack.append(num)
                elif preSign == '-':
                    stack.append(-num)
                elif preSign == '*':
                    stack.append(stack.pop() * num)
                else:
                    stack.append(int(stack.pop() / num))
                preSign = s[i]
                num = 0
        return sum(stack)
</code></pre>
<h3 id="a-name-p215-a-LC-215-数组中的第K个最大元素"><a name="p215"></a> <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LC-215 数组中的第K个最大元素</a></h3>
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br>
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>
示例 1:<br>
输入: [3,2,1,5,6,4] 和 k = 2<br>
输出: 5</p>
<p>直接用python heapq包处理</p>
<pre><code class="language-python">class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&gt; int:
        # 直接调用 python 包
        maxHeap = []
        for x in nums:
            heapq.heappush(maxHeap, -x)
        for _ in range(1, k, 1):
            heapq.heappop(maxHeap)
        print(maxHeap)
        return -maxHeap[0]
</code></pre>
<pre><code class="language-python">class Solution:
    def findKthLargest(self, nums: List[int], k: int) -&gt; int:
        heapsize = len(nums)
        def heapify(nums, index, heapsize):
            max = index
            left = 2 * index + 1
            right = 2 * index + 2
            if left &lt; heapsize and nums[left] &gt; nums[max]:
                max = left
            if right &lt; heapsize and nums[right] &gt; nums[max]:
                max = right
            if max != index:
                swap(nums, index, max)
                # 递归代入新的max节点
                heapify(nums, max, heapsize)

        def swap(nums, i, j):
            tmp = nums[i]
            nums[i] = nums[j]
            nums[j] = tmp

        def buildHeap(nums, heapsize):
            for i in range(heapsize // 2 - 1, -1, -1): # 只需要调整有子节点的父节点
                heapify(nums, i, heapsize)

        buildHeap(nums, heapsize)
        for i in range(k-1):
            swap(nums, 0, heapsize-1)
            heapsize -= 1
            heapify(nums, 0, heapsize)
        return nums[0]

</code></pre>
<h3 id="a-name-p145-a-LC-145-LRU缓存机制"><a name="p145"></a> <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LC-145 LRU缓存机制</a></h3>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>
实现 LRUCache 类：</p>
<p>双向链表，哈希表。<br>
其中双向链表可以更好的定位到前后的元素，而哈希表是记录所有 key 所在的位置</p>
<ol>
<li>get 操作：如果哈希表中有这个 key，则返回这个 key 的值，并且由于是最近使用的，所以需要将其移动至双向链表的头部；没有则返回-1</li>
<li>put 操作：将（key，value）的一个 pair 加入到双向链表中，这边就存在 2 种情况：如果有则直接修改值，并且移动至链表头部；如果没有值，则新建链表节点，移动至头部，并且需要检查总的长度是否超过 LRU 总的容量，超过则要删除链表中最后一个节点，并且在哈希表里也要弹出这个节点对应的 key。</li>
</ol>
<pre><code class="language-python">class DLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.cache = {}
        self.capacity = capacity
        self.size = 0
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head

    def addToHead(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next = node
        node.next.prev = node

    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def removeTail(self):
        node = self.tail.prev
        self.removeNode(node)
        return node

    def get(self, key: int) -&gt; int:
        if key not in self.cache:
            return -1
        # 如果 key 存在，先通过哈希表定位，再移到头部
        node = self.cache[key]
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -&gt; None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            # move to the header
            self.moveToHead(node)
        else:
            node = DLinkedNode(key, value)
            self.cache[key] = node
            # move to the header
            self.addToHead(node)
            self.size += 1
            if self.size &gt; self.capacity:
                # remove the tail
                removed = self.removeTail()
                self.cache.pop(removed.key)
                self.size -= 1
</code></pre>
<h3 id="a-name-p54-a-LC-54-螺旋矩阵"><a name="p54"></a> <a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">LC-54 螺旋矩阵</a></h3>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。<br>
<img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt=""></p>
<pre><code class="language-python">class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        left = top = 0
        right = len(matrix[0])
        bottom = len(matrix)
        ret = []
        while left &lt; right and top &lt; bottom:
            for i in range(left, right):
                ret.append(matrix[top][i])
            top += 1
            for i in range(top, bottom):
                ret.append(matrix[i][right - 1])
            right -= 1
            if left &lt; right and top &lt; bottom:
                for i in range(right - 1, left - 1, -1):
                    ret.append(matrix[bottom - 1][i])
                bottom -= 1
                for i in range(bottom - 1, top - 1, -1):
                    ret.append(matrix[i][left])
                left += 1
        return ret
</code></pre>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/13/LogisticsSummary/" rel="next" title="Logistics到softmax推导整理">
                <i class="fa fa-chevron-left"></i> Logistics到softmax推导整理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/25/信息流推荐要点/" rel="prev" title="信息流推荐算法小结">
                信息流推荐算法小结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alex Jiang</p>
              <p class="site-description motion-element" itemprop="description">身下万丈深渊，头上无尽苍穹</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#双指针"><span class="nav-number">1.1.</span> <span class="nav-text">双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">1.2.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">1.3.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">1.4.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学"><span class="nav-number">1.5.</span> <span class="nav-text">数学</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动窗口"><span class="nav-number">1.6.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找"><span class="nav-number">1.7.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回溯"><span class="nav-number">1.8.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-BFS"><span class="nav-number">1.9.</span> <span class="nav-text">DFS/BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">1.10.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">1.11.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p1-a-LC-1-2数求和"><span class="nav-number">2.0.1.</span> <span class="nav-text"> LC-1 2数求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p15-a-LC-15-3数求和"><span class="nav-number">2.0.2.</span> <span class="nav-text"> LC-15 3数求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p16-a-LC-16-最接近的三数之和"><span class="nav-number">2.0.3.</span> <span class="nav-text"> LC-16 最接近的三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p75-a-LC-75-颜色分类"><span class="nav-number">2.0.4.</span> <span class="nav-text"> LC-75 颜色分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p11-a-LC-11-盛最多水的容器"><span class="nav-number">2.0.5.</span> <span class="nav-text"> LC-11 盛最多水的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p763-a-LC-763-划分字母区间"><span class="nav-number">2.0.6.</span> <span class="nav-text"> LC-763 划分字母区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p80-a-LC-80-删除有序数组中的重复项-II"><span class="nav-number">2.0.7.</span> <span class="nav-text"> LC-80 删除有序数组中的重复项 II</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p300-a-LC-300-最长上升子序列"><span class="nav-number">3.0.1.</span> <span class="nav-text"> LC-300 最长上升子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p1143-a-LC-1143-最长公共子序列"><span class="nav-number">3.0.2.</span> <span class="nav-text"> LC-1143 最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p673-a-LC-673-最长递增子序列的个数"><span class="nav-number">3.0.3.</span> <span class="nav-text"> LC-673 最长递增子序列的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p5-a-LC-5-最长回文子串"><span class="nav-number">3.0.4.</span> <span class="nav-text"> LC-5 最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p647-a-LC-647-回文子串"><span class="nav-number">3.0.5.</span> <span class="nav-text"> LC-647 回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p516-a-LC-516-最长回文子序列"><span class="nav-number">3.0.6.</span> <span class="nav-text"> LC-516 最长回文子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p221-a-LC-221-最大正方形"><span class="nav-number">3.0.7.</span> <span class="nav-text"> LC-221 最大正方形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p322-a-LC-322-零钱兑换"><span class="nav-number">3.0.8.</span> <span class="nav-text"> LC-322 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p718-a-LC-718-最长重复子数组"><span class="nav-number">3.0.9.</span> <span class="nav-text"> LC-718 最长重复子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p198-a-LC-198-打劫家舍"><span class="nav-number">3.0.10.</span> <span class="nav-text"> LC-198 打劫家舍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p213-a-LC-213-打劫家舍2"><span class="nav-number">3.0.11.</span> <span class="nav-text"> LC-213 打劫家舍2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p62-a-LC-62-不同路径"><span class="nav-number">3.0.12.</span> <span class="nav-text"> LC-62 不同路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p63-a-LC-63-不同路径2"><span class="nav-number">3.0.13.</span> <span class="nav-text"> LC-63 不同路径2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p63-a-LC-64-最小路径和"><span class="nav-number">3.0.14.</span> <span class="nav-text"> LC-64 最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p152-a-LC-152-乘积最大子数组"><span class="nav-number">3.0.15.</span> <span class="nav-text"> LC-152 乘积最大子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p523-a-LC-523-连续的子数组和"><span class="nav-number">3.0.16.</span> <span class="nav-text"> LC-523 连续的子数组和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p139-a-LC-139-单词拆分"><span class="nav-number">3.0.17.</span> <span class="nav-text"> LC-139 单词拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p264-a-LC-264-丑数2"><span class="nav-number">3.0.18.</span> <span class="nav-text"> LC-264 丑数2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p279-a-LC-279-完全平方数"><span class="nav-number">3.0.19.</span> <span class="nav-text"> LC-279 完全平方数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p309-a-LC-309-最佳买卖股票时机含冷冻期"><span class="nav-number">3.0.20.</span> <span class="nav-text"> LC-309 最佳买卖股票时机含冷冻期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p188-a-LC-188-买卖股票的最佳时机-IV"><span class="nav-number">3.0.21.</span> <span class="nav-text"> LC-188 买卖股票的最佳时机 IV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p343-a-LC-343-整数拆分"><span class="nav-number">3.0.22.</span> <span class="nav-text"> LC-343 整数拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p416-a-LC-416-分割等和子集"><span class="nav-number">3.0.23.</span> <span class="nav-text"> LC-416 分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p42-a-LC-42-接雨水"><span class="nav-number">3.0.24.</span> <span class="nav-text"> LC-42 接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p32-a-LC-32-最长有效括号"><span class="nav-number">3.0.25.</span> <span class="nav-text"> LC-32 最长有效括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p72-a-LC-72-编辑距离"><span class="nav-number">3.0.26.</span> <span class="nav-text"> LC-72 编辑距离</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p103-a-LC-103-二叉树锯齿形便利"><span class="nav-number">4.0.1.</span> <span class="nav-text"> LC-103 二叉树锯齿形便利</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p103-a-LC-102-二叉树的层序遍历"><span class="nav-number">4.0.2.</span> <span class="nav-text"> LC-102 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p107-a-LC-107-二叉树的层序遍历2"><span class="nav-number">4.0.3.</span> <span class="nav-text"> LC-107 二叉树的层序遍历2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p236-a-LC-236-二叉树的最近公共祖先"><span class="nav-number">4.0.4.</span> <span class="nav-text"> LC-236 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p98-a-LC-98-验证二叉搜索树"><span class="nav-number">4.0.5.</span> <span class="nav-text"> LC-98 验证二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p199-a-LC-199-二叉树右视图"><span class="nav-number">4.0.6.</span> <span class="nav-text"> LC-199 二叉树右视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p101-a-LC-101-对称二叉树"><span class="nav-number">4.0.7.</span> <span class="nav-text"> LC-101 对称二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p105-a-LC-105-从前序与中序遍历序列构造二叉树"><span class="nav-number">4.0.8.</span> <span class="nav-text"> LC-105 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p112-a-LC-112-路径总和"><span class="nav-number">4.0.9.</span> <span class="nav-text"> LC-112 路径总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p113-a-LC-113-路径总和-II"><span class="nav-number">4.0.10.</span> <span class="nav-text"> LC-113 路径总和 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p124-a-LC-124-二叉树中的最大路径和"><span class="nav-number">4.0.11.</span> <span class="nav-text"> LC-124 二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p129-a-LC-129-求根节点到叶节点数字之和"><span class="nav-number">4.0.12.</span> <span class="nav-text"> LC-129 求根节点到叶节点数字之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p958-a-LC-958-二叉树的完全性检验"><span class="nav-number">4.0.13.</span> <span class="nav-text"> LC-958 二叉树的完全性检验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p104-a-LC-104-二叉树的最大深度"><span class="nav-number">4.0.14.</span> <span class="nav-text"> LC-104 二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p226-a-LC-226-反转二叉树"><span class="nav-number">4.0.15.</span> <span class="nav-text"> LC-226 反转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p114-a-LC-114-二叉树展开成链表"><span class="nav-number">4.0.16.</span> <span class="nav-text"> LC-114 二叉树展开成链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p230-a-LC-230-二叉树搜索树中的第k个小的元素"><span class="nav-number">4.0.17.</span> <span class="nav-text"> LC-230 二叉树搜索树中的第k个小的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p662-a-LC-662-二叉树最大宽度"><span class="nav-number">4.0.18.</span> <span class="nav-text"> LC-662 二叉树最大宽度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p206-a-LC-206-反转链表"><span class="nav-number">5.0.1.</span> <span class="nav-text"> LC-206 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p25-a-LC-25-K个一组反转链表"><span class="nav-number">5.0.2.</span> <span class="nav-text"> LC-25 K个一组反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p92-a-LC-92-反转链表2"><span class="nav-number">5.0.3.</span> <span class="nav-text"> LC-92 反转链表2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p21-a-LC-21-合并两个有序链表"><span class="nav-number">5.0.4.</span> <span class="nav-text"> LC-21 合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p23-a-LC-23-合并k个有序链表"><span class="nav-number">5.0.5.</span> <span class="nav-text"> LC-23 合并k个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p141-a-LC-141-环形链表"><span class="nav-number">5.0.6.</span> <span class="nav-text"> LC-141 环形链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p142-a-LC-142-环形链表2"><span class="nav-number">5.0.7.</span> <span class="nav-text"> LC-142 环形链表2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p160-a-LC-160-相交链表"><span class="nav-number">5.0.8.</span> <span class="nav-text"> LC-160 相交链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p19-a-LC-19-删除链表的倒数第-N-个结点"><span class="nav-number">5.0.9.</span> <span class="nav-text"> LC-19 删除链表的倒数第 N 个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p143-a-LC-143-重排链表"><span class="nav-number">5.0.10.</span> <span class="nav-text"> LC-143 重排链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p234-a-LC-234-回文链表"><span class="nav-number">5.0.11.</span> <span class="nav-text"> LC-234 回文链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p148-a-LC-148-排序链表"><span class="nav-number">5.0.12.</span> <span class="nav-text"> LC-148 排序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p83-a-LC-83-删除排序链表中的重复元素"><span class="nav-number">5.0.13.</span> <span class="nav-text"> LC-83 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p24-a-LC-24-两两交换链表中的节点"><span class="nav-number">5.0.14.</span> <span class="nav-text"> LC-24 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p328-a-LC-328-奇偶链表"><span class="nav-number">5.0.15.</span> <span class="nav-text"> LC-328 奇偶链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p61-a-LC-61-旋转链表"><span class="nav-number">5.0.16.</span> <span class="nav-text"> LC-61 旋转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p86-a-LC-86-分隔链表"><span class="nav-number">5.0.17.</span> <span class="nav-text"> LC-86 分隔链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p82-a-LC-82-删除排序链表中的重复元素2"><span class="nav-number">5.0.18.</span> <span class="nav-text"> LC-82 删除排序链表中的重复元素2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p2-a-LC-2-两数相加"><span class="nav-number">6.0.1.</span> <span class="nav-text"> LC-2 两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p8-a-LC-8-字符串转换整数-atoi"><span class="nav-number">6.0.2.</span> <span class="nav-text"> LC-8 字符串转换整数 (atoi)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p8-a-LC-50-Pow-x-n"><span class="nav-number">6.0.3.</span> <span class="nav-text"> LC-50 Pow(x, n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p43-a-LC-43-字符串相乘"><span class="nav-number">6.0.4.</span> <span class="nav-text"> LC-43 字符串相乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p470-a-LC-470-用-Rand7-实现-Rand10"><span class="nav-number">6.0.5.</span> <span class="nav-text"> LC-470 用 Rand7() 实现 Rand10()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p12-a-LC-12-整数转罗马数字"><span class="nav-number">6.0.6.</span> <span class="nav-text"> LC-12 整数转罗马数字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">7.</span> <span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p3-a-LC-3-无重复字符的最长子串"><span class="nav-number">7.0.1.</span> <span class="nav-text"> LC-3 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p76-a-LC-76-最小覆盖子串"><span class="nav-number">7.0.2.</span> <span class="nav-text"> LC-76 最小覆盖子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p239-a-LC-239-滑动窗口最大值"><span class="nav-number">7.0.3.</span> <span class="nav-text"> LC-239 滑动窗口最大值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">8.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p33-a-LC-33-搜索旋转排序数组"><span class="nav-number">8.0.1.</span> <span class="nav-text"> LC-33 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p162-a-LC-163-寻找峰值"><span class="nav-number">8.0.2.</span> <span class="nav-text"> LC-163 寻找峰值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p240-a-LC-240-搜索二维矩阵-II"><span class="nav-number">8.0.3.</span> <span class="nav-text"> LC-240 搜索二维矩阵 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p31-a-LC-31-下一个排列"><span class="nav-number">8.0.4.</span> <span class="nav-text"> LC-31 下一个排列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">9.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p46-a-LC-46-全排列"><span class="nav-number">9.0.1.</span> <span class="nav-text"> LC-46 全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p78-a-LC-78-子集"><span class="nav-number">9.0.2.</span> <span class="nav-text"> LC-78 子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p77-a-LC-77-组合"><span class="nav-number">9.0.3.</span> <span class="nav-text"> LC-77 组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p39-a-LC-39-组合总和"><span class="nav-number">9.0.4.</span> <span class="nav-text"> LC-39 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p22-a-LC-22-括号生成"><span class="nav-number">9.0.5.</span> <span class="nav-text"> LC-22 括号生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p79-a-LC-79-单词搜索"><span class="nav-number">9.0.6.</span> <span class="nav-text"> LC-79 单词搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p47-a-LC-47-全排列2"><span class="nav-number">9.0.7.</span> <span class="nav-text"> LC-47 全排列2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p40-a-LC-47-全组合2"><span class="nav-number">9.0.8.</span> <span class="nav-text"> LC-47 全组合2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">10.</span> <span class="nav-text">DFS/BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p200-a-LC-200-岛屿数量"><span class="nav-number">10.0.1.</span> <span class="nav-text"> LC-200 岛屿数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p695-a-LC-695-岛屿的最大面积"><span class="nav-number">10.0.2.</span> <span class="nav-text"> LC-695 岛屿的最大面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p394-a-LC-394-字符串解码"><span class="nav-number">10.0.3.</span> <span class="nav-text"> LC-394 字符串解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p207-a-LC-207-课程表"><span class="nav-number">10.0.4.</span> <span class="nav-text"> LC-207 课程表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p106-a-LC-106-从中序与后序遍历序列构造二叉树"><span class="nav-number">10.0.5.</span> <span class="nav-text"> LC-106 从中序与后序遍历序列构造二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">11.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p151-a-LC-151-翻转字符串里的单词"><span class="nav-number">11.0.1.</span> <span class="nav-text"> LC-151 翻转字符串里的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p165-a-LC-165-比较版本号"><span class="nav-number">11.0.2.</span> <span class="nav-text"> LC-165 比较版本号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p93-a-LC-93-复原ip地址"><span class="nav-number">11.0.3.</span> <span class="nav-text"> LC-93 复原ip地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p227-a-LC-227-基本计算器2"><span class="nav-number">11.0.4.</span> <span class="nav-text"> LC-227 基本计算器2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p215-a-LC-215-数组中的第K个最大元素"><span class="nav-number">11.0.5.</span> <span class="nav-text"> LC-215 数组中的第K个最大元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p145-a-LC-145-LRU缓存机制"><span class="nav-number">11.0.6.</span> <span class="nav-text"> LC-145 LRU缓存机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-name-p54-a-LC-54-螺旋矩阵"><span class="nav-number">11.0.7.</span> <span class="nav-text"> LC-54 螺旋矩阵</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Jiang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



<script src="/js/prism/prism.js" async></script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://alex44jzy.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://alexjiangzy.com/2021/07/25/分类总结/';
          this.page.identifier = '2021/07/25/分类总结/';
          this.page.title = '分类总结';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://alex44jzy.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  

















  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
